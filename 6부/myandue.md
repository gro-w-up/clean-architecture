## 30장. 데이터베이스는 세부사항이다

- 애플리케이션 내부 데이터의 구조인 데이터 모델은 시스템 아키텍처에서 대단히 중요하다. 여기서 말하는 데이터베이스는 그저 데이터에 접근할 방법을 제공하는 유틸리티이다.
- 해당 데이터베이스는 저수준의 세부사항이다. 세부사항으로 아키텍처를 오염시키면 안된다.
- **관계형 데이터베이스**
    - 관계형 데이터베이스는 이러건저러건 그저 기술이다. 세부사항이다.
    - 데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야한다.
- **데이터베이스 시스템은 왜 이렇게 널리 사용되는가?**
    - 데이터 저장소로서 회전식 자기 디스크를 써왔는데, 이런저런 장점에도 불구하고 느리다는 특성이 있다.
    - 데이터 관리는 크게 파일 시스템과 관계형 데이터베이스 관리 시스템으로 분리되었다.
    - 파일 시스템은 문서 기반으로, 이름 기준으로 저장 및 조회는 잘 되지만 내용 기준 조회는 어렵고 오래 걸린다.
    - 데이터베이스 시스템은 내용을 기반으로 레코드를 편하게 찾는 방법을제공한다.  정형화된 문서에 한해서!
    - 두 시스템은 결국 데이터를 빠르게 조작할 수 있도록 관련 있는 데이터를 RAM으로 가져온다.
- **디스크가 없다면 어떻게 될까?**
    - 데이터가 실상 어디에 어떻게 저장되어있건 RAM으로 읽은 후 다루기  편리한 형태로 그 구조를 변경한다.
- **세부사항**
    - 데이터베이스틑 그저 디스크 표면과 RAM 사이에서 데이터를 이리저리 옮길 때 사용할 뿐이다. 그저 공간일 뿐이다.
    - 따라서 아키텍처 관점에서, 데이터가 존재만 한다면 어디에 어떤 형태로 저장돼있건 우리는 알 필요가 없다는 것이다.
- **하지만 성능은?**
    - 데이터 저장소 측면의 성능은 저수준의 관심사이다. 시스템의 전반적인 아키텍처와는 아무런 관련이 없다.
- **결론**
    - 체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다.
    - 하지만 그저 데이터를 저장하고 옮길뿐인 데이터베이스 시스템은 아키텍처적으로 중요치 않다.

<br>

## 31장. 웹은 세부사항이다

- 애플리케이션의 연산 능력은 브라우저와 서버 사이를 왔다갔다 해왔다.
- **끝없이 반복하는 추**
    - 앞으로도 우리는 연산 능력을 어디에 둘디 알 수 없을 것이다. 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다. (이걸 그저 진동이라고 표현한다)
    - 저러한 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 문제이다.
    - 업무 규칙을 UI로부터 분리해야 UI의 흐름이 어떻게 흘러가건 우리의 코드가 안전해질 수 있다.
- **요약**
    - GUI는 세부사항이고 웹은 GUI다. 따라서 웹은 세부사항이다. 그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.
    - UI는 그저 입력 데이터와 출력 데이터를 외부와 유스케이스 사이에서 움직이게 하는 장치일뿐이다.
- **결론**
    - 이러한 종류의 추상화는 만들기 쉽지 않지만 가능하다. 네 코드를 마케팅 귀재로부터 지키고 싶다면 추상화에 힘써라.
    - 근데 논외로 내가 우리 팀 프론트 개발자한테 프론트도 클린 아키텍처를 하냐 물었더니 한다고 한다. 물어본 이유는, 이 책에서 말하는 세부사항과의 분리가 너무 어려워보여서,,, 요새도 회사에서 겪는게, 외부 QA를 받으면 실상 로직적으로 문제가 있기보다는 UI적으로? 문제가 있어서 프론트가 바쁘다. (그래서 나는 그냥 백엔드로 있으려고,,)

<br>

### 32장. 프레임워크는 세부사항이다

- **프레임워크 제작자**
    - 프레임워크 제작자는 당신의 문제를 알지 못한다.
- **혼인 관계의 비대칭성**
    - 프레임워크를 사용하게되면, 본인의 코드와 결합이 시작되면 그것을 분리해낼 수 없다.
    - 프레임워크 제작자는 그를 통해 해당 프레임워크의 효능을 뽐낼 수 있고(사용자가 못 도망가니까), 내 코드는 프레임워크의 변화에 의해 움직여질 수밖에 없다.
- **위험 요인**
    - 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많다. 제작자는 본인의 프레임워크가 사용자의 가장 안쪽 원과 결합되기를 원한다. 한번 그렇게 되면 이제 그것은 원 밖으로 나오지 않는다.
    - 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 될 것이나, 제품이 성숙해지면서 프레임워크의 기능과 틀을 벗어나게 될 것이다.
    - 프레임워크가 내가 원하는 방향과는 전혀 다르게 진화할 수도 있다.
    - 더 나은 프레임워크가 나타나면 갈아타고 싶어질 수 있다.
- **해결책**
    - Q. 해결책은 무엇인가? A. 프레임워크와 결혼하지 말라!
    - 프레임워크가 안쪽 원으로 들어오지 못하게 거리를 둬라.
    - 프레임워크를 상속하지 말고, proxy를 만들어 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 proxy를 위치시켜라. (proxy를 만들라는건 뭘까? proxy가 뭔지도 모른다)
    - 핵심 코드에 직접 넣지 말고, 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합해서 의존성 규칙을 준수하라.
    - 예를 들어 당신은 스프링을 좋아할 것이다.(계속해서 스프링 생각하고 있었는데 딱 들켰다. 그럼 나보고 순수 자바로 코딩을 하라고?? 라고 계속 반문하고 있었는데)
    업무 객체에 스프링을 사용하지 말고, 최저 수준의 컴포넌트인 메인(Main) 컴포넌트에서 스프링을 이용한 의존성 주입을 해라.
- **이제 선언합니다**
    - 결혼해야만 하는 프레임워크도 존재한다.고 말하네 ㅋㅋㅋ C++은 STL과 해야하고 자바는 표준 라이브러리와 결혼해야한다고 한다. 피할 수 없다고. 하지만 가볍게 생각하지 말라고 한다.
- **결론**
    - 프레임워크와의 첫만남부터 바로 결혼하려 들지 말라.
    - 하지만 제 자바 프로젝트는 spring.io로부터 시작되는걸요,,

<br>

### 33장. 사례 연구: 비디오 판매

- **제품**
    - 사례 연구로 비디오 판매자와 구매자가 이용하는 웹사이트를 가져왔다.
    - 시스템의 초기 아키텍처를 결정하는 첫 단계는 액터와 유스케이스를 식별하는 일이다.
- **유스케이스 분석**
    - 해당 예시의 주요 액터를 네가지로 분류했다.
        - 제작자
        - 관리자
        - 구매자
        - 시청자
    - 단일 책임 원칙에 따라, 신규 기능 추가 혹은 기존 기능 변경이 발생한다면 그 이유는 이 네가지 액터 중 하나에 있어야 한다. 그리고 해당 액터를 위한 변경이 다른 액터에 영향을 미쳐서는 안된다.
- **컴포넌트 아키텍처**
    - 아키텍처적으로 필요한 경계를 생성한다. 해당 예시에서는 ‘뷰 - 프레젠터 - 인터랙터 - 컨트롤러’ 사이에 경계를 생성했다.
    - 그리고 해당 경계 내에서 대응 액터에 따라 카테고리를 분류하였다.(제작자, 관리자, 구매자, 시청자)
    - 각각의 시스템이 배포 독립성을 갖을 수 있도록 한다. (별도의 컴포넌트. 별도의 .jar 파일)
    이 부분은 음.. 아키텍처적으로는 온전히 분리하는게 좋지만 모든 서비스들이 그렇듯 상황에 맞게 분리하면된다.
- **의존성 관리**
    - 제어흐름의 방향은 다음과 같다. ‘컨트롤러 → 인터랙터 → 프레젠터 → 뷰’. 제어흐름이란 발생한 결과가 영향을 미치는 방향? 이라고 보면 될 것 같다.
    - 하지만 의존성의 방향은 위 제어흐름과 같지 않다. 의존성의 방향은 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향한다. ‘컨트롤러 → 인터랙터 ← 프레젠터 ← 뷰’. 인터랙터를 통해 의존성 역전을 준수할 수 있다.
    - 저수준의 세부사항 변경이 고수준의 정책에 영향을 미치지 않도록 해야한다.
- **결론**
    - 단일 책임 원칙에 기반한 액터의 분리 - 서로 다른 이유
    - 의존성 규칙 - 서로 다른 속도
    - 이 장을 통해, 내가 클린 아키텍처를 준수한 프로젝트를 시작하기에 앞서 무엇을 해야할지 알 수 있었다. 우선 액터를 골라내고 분리해야한다.

<br>

### 34장. 빠져 있는 장

- 이 장 나는 좀 많이 어려웠다. 음.. 패키지.. 분류가 잘 안와닿아서 어려웠다.
- 괄호로 패키지를 묶어서 정리할거다.
- **계층 기반 패키지**
    - 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 수평적으로 분할한다.
    - 컨트롤러 & 서비스 & 리포지토리
    - (OrderController) → (OrdersService ← OrderServiceImpl) → (OrdersRepository ← JdbcOrderRepository)
    - 이 아키텍처 형태는 업무 도메인에 대해 아무것도 말해주지 않는다고 한다. 전혀 다른 업무 도메인이어도 웹&서비스&리포지토리 로 구성된 모습이 매우 비슷해 보인다. (그럼 도메인별로 패키지 구성을 다르게 가져가야하는거야..?)
    - 아 이거 Controller 패키지에 Order 도메인의 컨트롤러, 뭐 User 도메인의 컨트롤러 이렇게 다 들어가고 그런걸 의미하는걸까?
- **기능 기반 패키지**
    - 서로 연관된 기능, 도메인 개념에 기반하여 수직적으로 분할한다.
    - 클래스 형태는 위와 같지만, 하나의 도메인이 하나의 패키지에 묶인다.
    - (OrdersController → OrdersService ← OrdersServiceImpl → OrdersRepository ← JdbcOrderRepository)
    - 특정 유스케이스의 변경에 대해 대응하기가 좀 더 쉬워질 수 있다. (도메인 파악이 빨리 되니까)
- **포트와 어댑터**
    - ‘내부’(도메인)와 ‘외부’(인프라)로 나눈다. ‘외부’는 UI, 데이터베이스 등 세부사항들이다.
    - (OrdersController) → (OrdersService ← OrdersServiceImpl → Orders) ← (JdbcOrdersRepository)
    - 가운데 패키지가 ‘내부’에 해당하며 컨트롤러와 리포지토리 쪽이 ‘외부’이다.
    - 여기서, “도메인 주도 설계에서는 ‘내부’에 존재하는 모든 것의 이름은 반드시 ‘유비쿼터스 도메인 언어’ 관점에서 기술하라고 조언한다. 바꿔 말하면, 도메인에 대해 논의할 때 우리는 ‘주문’에 대해 말하는 것이지, ‘주문 리포지터리’에 대해 말하는 것이 아니다.” 라고 하는데 근데 결국 해당 Orders 인터페이스가 하는 일은 리포지토리 역할 아닌가요?
- **컴포넌트 기반 패키지**
    - 계층형 기반 패키지를 좋지 않은 아키텍처로 여기는 이유를 설명한다. 계층 기반 패키지에서는 기술적으로 패키지 분류가 되는데, 그렇게 되면 OrdersController가 OrdersService 인터페이스에 의존하기 위해 OrdersService 인터페이스가 public으로 선언되어야만 한다.
    - 이렇게 되면 원하는대로 비순환 의존성 그래프를 잘 만들었다고 할 수 있지만, 현재 위 예시에서 OrdersService 인터페이스와 OrdersRepository 인터페이스가 public으로 선언되어야만하고, 이렇게 되면 OrdersController가 OrdersService를 통하지 않고 OrdersRepository에 접근할 수도 있게되는 것이다. 의도치 않은 이런 우회 루트가 생기는 것은 좋지 않다.
    - 이를 위해 컨트롤러의 리포지토리에 대한 직접 접근을 강제로 막을 수 있는 방도가 필요한데, 저자는 갖가지 도구를 이용하기보다는 컴파일 단계에서 강제성을 부여할 것을 권고한다. 내가 생각해도 그게 좋을 것 같다.
    - 그렇기때문에 ‘컴포넌트 기반 패키지’를 도입하라고 한다.
    - (OrdersController) → (OrdersComponent ← OrdersComponentImpl → OrdersRepository ← JdbcOrdersRepository)
    - 저자는 컴포넌트에 대한 정의를 아래와 같이 내렸다.
        - “컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다.”
- **구현 세부사항엔 항상 문제가 있다**
    - public 지시자의 남발은 내가 설계한 아키텍처를 무너뜨린다. 아키텍처를 지키기 위해서는 프로그래밍 언어가 제공하는 캡슐화의 이점을 잘 활용해야한다.
- **조직화 vs. 캡슐화**
    - 자바 애플리케이션에서 모든 타입을 public으로 지정하면 패키지는 그저 우리 컴퓨터의 ‘내 폴더’ 같은 그저 폴더가 될 뿐이다.
    - 자바의 정석에서 이 지시자 부분 이해 안가서 그냥 넘어갔는데, 이제 좀 알 것 같다. private은 파일?클래스?, proteted는 패키지 제한인가보다? (안찾아봄). 이전에 이걸 이해하기를 포기한게 protected의 존재 이유가 납득이 안갔기 때문이었다. private이면 private이고 public이면 public이지 protected는 왜 있는데.. 싶었는데 이렇게 보니 존재 이유를 알 것 같기도.
- **결론: 빠져 있는 조언**
    - 이 장이 나한테 꽤나 실질적인 도움이 된 것같다. 최적의 설계를 했어도 아차! 싶으면 바로 망가질 수 있으니, 아키텍처를 유지하기 위한 강제성 부여를 컴파일 단계에서 할 수 있도록 하라는 점이 말이다.

<br>

