## 30장. 데이터베이스는 세부사항이다

- 애플리케이션 내부 데이터의 구조인 데이터 모델은 시스템 아키텍처에서 대단히 중요하다. 여기서 말하는 데이터베이스는 그저 데이터에 접근할 방법을 제공하는 유틸리티이다.
- 해당 데이터베이스는 저수준의 세부사항이다. 세부사항으로 아키텍처를 오염시키면 안된다.
- **관계형 데이터베이스**
    - 관계형 데이터베이스는 이러건저러건 그저 기술이다. 세부사항이다.
    - 데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야한다.
- **데이터베이스 시스템은 왜 이렇게 널리 사용되는가?**
    - 데이터 저장소로서 회전식 자기 디스크를 써왔는데, 이런저런 장점에도 불구하고 느리다는 특성이 있다.
    - 데이터 관리는 크게 파일 시스템과 관계형 데이터베이스 관리 시스템으로 분리되었다.
    - 파일 시스템은 문서 기반으로, 이름 기준으로 저장 및 조회는 잘 되지만 내용 기준 조회는 어렵고 오래 걸린다.
    - 데이터베이스 시스템은 내용을 기반으로 레코드를 편하게 찾는 방법을제공한다.  정형화된 문서에 한해서!
    - 두 시스템은 결국 데이터를 빠르게 조작할 수 있도록 관련 있는 데이터를 RAM으로 가져온다.
- **디스크가 없다면 어떻게 될까?**
    - 데이터가 실상 어디에 어떻게 저장되어있건 RAM으로 읽은 후 다루기  편리한 형태로 그 구조를 변경한다.
- **세부사항**
    - 데이터베이스틑 그저 디스크 표면과 RAM 사이에서 데이터를 이리저리 옮길 때 사용할 뿐이다. 그저 공간일 뿐이다.
    - 따라서 아키텍처 관점에서, 데이터가 존재만 한다면 어디에 어떤 형태로 저장돼있건 우리는 알 필요가 없다는 것이다.
- **하지만 성능은?**
    - 데이터 저장소 측면의 성능은 저수준의 관심사이다. 시스템의 전반적인 아키텍처와는 아무런 관련이 없다.
- **결론**
    - 체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다.
    - 하지만 그저 데이터를 저장하고 옮길뿐인 데이터베이스 시스템은 아키텍처적으로 중요치 않다.

<br>

## 31장. 웹은 세부사항이다

- 애플리케이션의 연산 능력은 브라우저와 서버 사이를 왔다갔다 해왔다.
- **끝없이 반복하는 추**
    - 앞으로도 우리는 연산 능력을 어디에 둘디 알 수 없을 것이다. 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다. (이걸 그저 진동이라고 표현한다)
    - 저러한 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 문제이다.
    - 업무 규칙을 UI로부터 분리해야 UI의 흐름이 어떻게 흘러가건 우리의 코드가 안전해질 수 있다.
- **요약**
    - GUI는 세부사항이고 웹은 GUI다. 따라서 웹은 세부사항이다. 그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.
    - UI는 그저 입력 데이터와 출력 데이터를 외부와 유스케이스 사이에서 움직이게 하는 장치일뿐이다.
- **결론**
    - 이러한 종류의 추상화는 만들기 쉽지 않지만 가능하다. 네 코드를 마케팅 귀재로부터 지키고 싶다면 추상화에 힘써라.
    - 근데 논외로 내가 우리 팀 프론트 개발자한테 프론트도 클린 아키텍처를 하냐 물었더니 한다고 한다. 물어본 이유는, 이 책에서 말하는 세부사항과의 분리가 너무 어려워보여서,,, 요새도 회사에서 겪는게, 외부 QA를 받으면 실상 로직적으로 문제가 있기보다는 UI적으로? 문제가 있어서 프론트가 바쁘다. (그래서 나는 그냥 백엔드로 있으려고,,)

<br>

### 32장. 프레임워크는 세부사항이다

- **프레임워크 제작자**
    - 프레임워크 제작자는 당신의 문제를 알지 못한다.
- **혼인 관계의 비대칭성**
    - 프레임워크를 사용하게되면, 본인의 코드와 결합이 시작되면 그것을 분리해낼 수 없다.
    - 프레임워크 제작자는 그를 통해 해당 프레임워크의 효능을 뽐낼 수 있고(사용자가 못 도망가니까), 내 코드는 프레임워크의 변화에 의해 움직여질 수밖에 없다.
- **위험 요인**
    - 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많다. 제작자는 본인의 프레임워크가 사용자의 가장 안쪽 원과 결합되기를 원한다. 한번 그렇게 되면 이제 그것은 원 밖으로 나오지 않는다.
    - 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 될 것이나, 제품이 성숙해지면서 프레임워크의 기능과 틀을 벗어나게 될 것이다.
    - 프레임워크가 내가 원하는 방향과는 전혀 다르게 진화할 수도 있다.
    - 더 나은 프레임워크가 나타나면 갈아타고 싶어질 수 있다.
- **해결책**
    - Q. 해결책은 무엇인가? A. 프레임워크와 결혼하지 말라!
    - 프레임워크가 안쪽 원으로 들어오지 못하게 거리를 둬라.
    - 프레임워크를 상속하지 말고, proxy를 만들어 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 proxy를 위치시켜라. (proxy를 만들라는건 뭘까? proxy가 뭔지도 모른다)
    - 핵심 코드에 직접 넣지 말고, 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합해서 의존성 규칙을 준수하라.
    - 예를 들어 당신은 스프링을 좋아할 것이다.(계속해서 스프링 생각하고 있었는데 딱 들켰다. 그럼 나보고 순수 자바로 코딩을 하라고?? 라고 계속 반문하고 있었는데)
    업무 객체에 스프링을 사용하지 말고, 최저 수준의 컴포넌트인 메인(Main) 컴포넌트에서 스프링을 이용한 의존성 주입을 해라.
- **이제 선언합니다**
    - 결혼해야만 하는 프레임워크도 존재한다.고 말하네 ㅋㅋㅋ C++은 STL과 해야하고 자바는 표준 라이브러리와 결혼해야한다고 한다. 피할 수 없다고. 하지만 가볍게 생각하지 말라고 한다.
- **결론**
    - 프레임워크와의 첫만남부터 바로 결혼하려 들지 말라.
    - 하지만 제 자바 프로젝트는 spring.io로부터 시작되는걸요,,

<br>

### 33장. 사례 연구: 비디오 판매

- **제품**
    - 사례 연구로 비디오 판매자와 구매자가 이용하는 웹사이트를 가져왔다.
    - 시스템의 초기 아키텍처를 결정하는 첫 단계는 액터와 유스케이스를 식별하는 일이다.
- **유스케이스 분석**
    - 해당 예시의 주요 액터를 네가지로 분류했다.
        - 제작자
        - 관리자
        - 구매자
        - 시청자
    - 단일 책임 원칙에 따라, 신규 기능 추가 혹은 기존 기능 변경이 발생한다면 그 이유는 이 네가지 액터 중 하나에 있어야 한다. 그리고 해당 액터를 위한 변경이 다른 액터에 영향을 미쳐서는 안된다.
- **컴포넌트 아키텍처**
    - 아키텍처적으로 필요한 경계를 생성한다. 해당 예시에서는 ‘뷰 - 프레젠터 - 인터랙터 - 컨트롤러’ 사이에 경계를 생성했다.
    - 그리고 해당 경계 내에서 대응 액터에 따라 카테고리를 분류하였다.(제작자, 관리자, 구매자, 시청자)
    - 각각의 시스템이 배포 독립성을 갖을 수 있도록 한다. (별도의 컴포넌트. 별도의 .jar 파일)
    이 부분은 음.. 아키텍처적으로는 온전히 분리하는게 좋지만 모든 서비스들이 그렇듯 상황에 맞게 분리하면된다.
- **의존성 관리**
    - 제어흐름의 방향은 다음과 같다. ‘컨트롤러 → 인터랙터 → 프레젠터 → 뷰’. 제어흐름이란 발생한 결과가 영향을 미치는 방향? 이라고 보면 될 것 같다.
    - 하지만 의존성의 방향은 위 제어흐름과 같지 않다. 의존성의 방향은 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향한다. ‘컨트롤러 → 인터랙터 ← 프레젠터 ← 뷰’. 인터랙터를 통해 의존성 역전을 준수할 수 있다.
    - 저수준의 세부사항 변경이 고수준의 정책에 영향을 미치지 않도록 해야한다.
- **결론**
    - 단일 책임 원칙에 기반한 액터의 분리 - 서로 다른 이유
    - 의존성 규칙 - 서로 다른 속도
    - 이 장을 통해, 내가 클린 아키텍처를 준수한 프로젝트를 시작하기에 앞서 무엇을 해야할지 알 수 있었다. 우선 액터를 골라내고 분리해야한다.

<br>
