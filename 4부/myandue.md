## 12장. 컴포넌트

- 컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
- 컴포넌트의 간략한 역사
    - 구시대에는 프로그램을 메모리의 어느 위치에 배치시킬지 개발자가 직접 지정해줘야했다.
    - 컴파일 시간을 단축시키기 위해 라이브러리를 애플리케이션과 분리시키고 애플리케이션과 메모리상 근접한 위치에 라이브러리를 위치시켰는데, 애플리케이션과 라이브러리 사이즈가 커져가면서 공간할당에 문제가 생길 수밖에 없게되어 변화가 필요했다.
    - 해결책으로, 지능적인 로더를 사용해 메모리를 재배치할 수 있도록 해주는 것이었다. 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시하면 된다. → 링킹 로더
    - 하지만 또, 사이즈가 커지면서 링킹 로더가 라이브러리를 읽고 외부 참조를 해석하는 데에 시간이 한참 걸리게 된다.
    - 그래서 로드와 링크가 두 단계로 분리되었는데, 프로그래머가 느린 부분인 링크 과정을 맡았다. ‘링커’라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다. 링커는 링크가 완료된 재배치 코드를 만들어주었고, 때문에 로더의 로딩 과정이 빨라질 수 있었다. (하지만 링커는 느리다. 그저 분리만 했을뿐.)
    - 당연하게도 사이즈가 커지면서 또 문제가 발생한다.
    - 해결책이 보이지 않았으나, 다행스럽게도 하드웨어의 폭발적인 발전으로 인해 메모리 상 문제가 해결돼버리고 말았다.
    - 링크 시간이 미친듯이 줄어들게 되면서 액티브 X와 공유 라이브러리 시대가 열렸고 .jar 파일도 등장하기 시작했다. 링크 및 실행의 속도가 어마무시하게 빨라지면서, ‘컴포넌트 플러그인 아키텍처’가 탄생한 것이다.
    - 결론. 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

<br>

## 13장. 컴포넌트 응집도

- 컴포넌트 응집도와 관련된 세 가지 원칙
    - REP: 재사용/릴리스 등가 원칙
    - CCP: 공통 폐쇄 원칙
    - CRP: 공통 재사용 원칙
- REP: 재사용/릴리스 등가 원칙
    - 재사용 단위는 릴리스 단위와 같다.
    - 와닿지가 않는다.
- CCP: 공통 폐쇄 원칙
    - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
    - 이 원칙은 ‘단일 책임 원칙’을 컴포넌트 관점에서 다시 쓴 것이다.
    - 애플리케이션에서 코드가 변경되어야 할 때, 여러 컴포넌트에서 분산돼서 발생하는 것이 아니라 단일 컴포넌트 내에서 발생해야한다는 것이다. 그렇게 되면 하나의 컴포넌트만 재배포하면 된다.
    - 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라!
- CRP: 공통 재사용 원칙
    - 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
    - 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다.
    - 무의미한 의존을 생성시키지 말라는 의미인 것같다.
- 컴포넌트 응집도에 대한 균형 다이어그램
    - REP와 CCP는 포함 원칙(컴포넌트를 더욱 크게)이고, CRP는 배제 원칙(컴포넌트를 더욱 작게)이다. 상충 되는 이 응집도 원칙들의 균형을 찾아야한다.
    - REP를 포기했을 때 → 재사용이 어려움
    - CCP를 포기했을 때 → 컴포넌트 변경이 너무 빈번함
    - CRP를 포기했을 때 → 불필요한 릴리스가 너무 빈번함
    - 이 균형은 시간의 흐름에 따라 변경될 수 있다. 개발 초기의 중요도는 ‘개발 가능성 > 재사용성’ 이기 때문에 CCP가 REP보다 더 중요하다. 하지만 프로젝트가 커지고, 파생된 프로젝트가 시작되고 한다면 REP가 더 중요해진다.(재사용성 > 개발 가능성)

<br>

## 14장. 컴포넌트 결합

- 컴포넌트 사이의 관계를 설명할 세 가지. 원칙
    - ADP: 의존성 비순환 원칙
    - SDP: 안정된 의존성 원칙
    - SAP: 안정된 추상화 원칙
- ADP: 의존성 비순환 원칙
    - 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
    - 순환이라는 말은, A가 의존하는 B 컴포넌트가 C를 의존하고, C가 A를 의존하는 형태를 의미한다.
    - 결국 A, B, C의 컴포넌트 분리가 의미 없이, A, B, C 통째로 하나의 컴포넌트가 되어버리는 것이다.
    - 이렇게 될 경우 A, B, C 어떤 것에 변화가 발생했을 때 모두가 그 변화를 감내해야한다.
    - 이럴 때 순환을 끊어내기위해 인터페이스를 분리해야한다. 인터페이스를 사이에 둠으로써 각각의 컴포넌트가 순환없이 해당 인터페이스에 의존하도록 만드는 것이다.
    - 근데 결론이 ‘컴포넌트 구조는 하향식으로 설계될 수 없다’이다. 왜때문이지?
- SDP: 안정된 의존성 원칙
    - 안정성의 방향으로(더 안정된 쪽에) 의존하라.
    - 설계는 결코 정적일 수 없고 때문에 변동은 발생할 수밖에 없다. 그 변동과 의존성 등등에 맞게 설계를 해야하는 것이다. ‘변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안된다.’
    - 불안정성 I = Fan-out / (Fan-in + Fan-out)
    - I=0 안정성이 높다 ⇒ fan-in이 없다. 본인을 의존하는 것이 없다.
    - I=1 안정성이 낮다 ⇒ fan-out없이 fan-in만 있다. 본인을 호출하는 것뿐이다.
    - 컴포넌트는 본인의 I 지수보다 낮은 I 지수를 갖는 컴포넌트에만 의존해야한다. 하지만 의존하고자 하는 컴포넌트가 유연성이 높은 컴포넌트이어야 할 수도 있다. 이럴 때 인터페이스를 분리해야하는 것이다.
    - 그리고 내가 이해한 ‘stable’, ‘안정적’은 진짜로 뭘해도 괜찮은 안정적. 편안함. 이게 아니라 ‘나를 변경했다간 다른 컴포넌트에도 영향이 가! 나를 쉽게 바꿀 수 없어! 였다. 즉, ‘안정적이다’ 가 아니라 ‘안정적으로 유지해야만 한다’ 인 것같다.
- SAP: 안정된 추상화 원칙
    - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
    - 인상적이었던점이, 추상화가 무조건적으로 그냥 중요한줄 알았는데, 아무도 호출하지 않는 컴포넌트가 추상적이어봤자 라는점이었다.
    - 이 부분은 주계열(Main Sequence)를 통해 확인할 수 있다.
        - x축은 불안정성(I): 0~1
        - y축은 추상화정도(A): 0~1
        - 그래프상 표기되지는 않지만 z축을 불변성? 정도로 보았을 때, 가장 가변적임을 가정하는 z=0의 상태(평면)을 보고있다고 생각하면 된다.
            - 이 부분은, 고통의 구역이라고 불리는 (0, 0) 과 같은 구역도 Java의 String과 같이 모두 구체적이지만 웬만해선 바뀔 일 없는 컴포넌트에게는 고통일 것도 없기 때문이다.
            - 하지만 일반적인 서비스는 보통 가변 가능성이 상당하니까!
    - 주계열은 (0,1) 과 (1,0) 을 잇는 선이다. 이 위에서 ‘불안정성’과 ‘추상화의 정도’의 균형을 맞추어야 하는 것이다.
    - (0, 0): 고통의 구역: 안정성이 높은데(본인에게 의존하는 것이 많은데) 추상화가 전혀 돼있지 않은 것이다. 이런 경우 뭐 하나 변경시키려하면 고통이다.
    - (1, 1): 쓸모없는 구역: 불안정성이 높은데(본인을 의존하는 것이 하나도 없는데) 추상적이기만 한 것이다. 나를 호출하는게 하나도 없는데 내가 이리 바뀌건 저리 바뀌건 상관 없는데 추상적인거임. (→ 내가 인상적이었다고 했던 부분이 이 부분이다.)
    - 표준편차(z)도 있는데, 주계열과 얼마나 먼 거리에 있느냐를 규정하는 수치이다.

<br>
