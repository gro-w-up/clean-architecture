## 23장 프레젠터와 험블 객체

### 험블 객체 패턴

- 험블객체패턴은 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- **구현방법은 행위들을 모두 두개의 클래스로 나눈 후 테스트하기 어려운 행위를 험블 객체에 옮기고 나머지는 다른 객체에 넣는다.**

### 프레젠터와 뷰

- 뷰는 험블 객체이고 테스트하기 어렵다. 데이터를 GUI로 이동시키지만 데이털르 직접 처리하지는 않는다
- 프레젠터는 테스트하기 쉬운 객체다. 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.
    - ex: Data 객체를 적절한 포맷의 문자열로 만드는 것

### 테스트와 아키텍처

- 테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다.
- 험블 객체 패턴이 좋은 예인데 아키텍처 경계가 정의되기 때문이다. (뷰 / 프레젠터)

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터 베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
- 데이터베이스는 험블객체이다. 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기때문에 험블 객체가 아니다. 그러므로 테스트하기 용이하다.
    - 이는 스텁(stub)이나 테스트 더블(test-double)로 적당히 교체할 수 있다.

### 데이터 매퍼

- 객체 관계 매퍼 같은건 사실 존재하지 않는다. 객체는 데이터구조가 아니기 때문이다.
- 객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다. ORM 보다는 데이터 매퍼라고 부르는 편이 나은데 관계형 데이터 베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주기 때문이다.
- ORM 시스템은 데이터 베이스 계층에 위치해야 한다.

### 서비스 리스너

- 서비스의 경우에도 서비스 경계를 생성하는 험블 객체 패턴을 발견할 수 있다.
- 데이터 구조를 경계를 가로질러서 특정 모듈로 전달한다. 그러면 해당 모듈은 데이터를 적절한 포맷으로 만들어서 외부 서비스로 전송한다. 해당 모듈은 데이터를 적절한 포맷으로 만들어서 외부 서비스로 전송한다.

### 결론

각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다. 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리되겠다. 이로인해 테스트의 용이성을 크게 높힐 수 있다.

## 24장 부분적 경계

아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. 비용이 너무 크다고 판단되면 부분적 경게를 구현해볼수 있다.

### 마지막 단계를 건너뛰기

- 컴파일하고 배포할 수 있는 컴포넌트를 만들고 단일 컴포넌트에 그대로 모아만 두는 것이다. 쌍방향 인터페이스도 그 컴포넌트에 있고 입력 출력 데이터. 구조도 거기에 있으며 모든것이 완전히 준비되어 있다.
- 하지만 완벽한 경계와 사전 설계가 충분히 필요하다.

### 일차원 경계

<img width="1000" alt="1" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/d7d5efdb-21d6-41f3-a681-d7769da72839">

- 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 Strategy 패턴을 사용한 전형적인 사례다.
    - ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceInpl 클래스가 구현한다.
- 이러한 분리는 빨간 점선처럼 오용해서는 안되도록 주의가 필요하다

### 퍼사드

- 이보다 단순한 경계는 퍼사드 패턴으로 Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.
- 클라이언트는 이들 서비스에 직접 접근할 수 없지만 Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.

### 결론

아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할이다.

## 25장 계층과 경계

시스템이 세가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성되지는 않을 수 있다.

- 게임 규칙, 게임의 예제에서 중요한 아키텍처 경계를 정말로 모두 발견한 것일까? 예를 들어 UI에서 언어가 유일한 변경의 축은 아니고 텍스트를 주고받는 매커니즘을 다양하게 만들고 싶을 수도 있다. 이 변경의 축에 의해 정의되는 아키텍처 경계가 잠재되어 있을 수 있다.

### 흐름 분리하기

- 항상 상단의 단일 컴포넌트에서 서로 만나지는 않는다.
- 이보다 더 높은 수준에는 또다른 정책 집합이 존재하는데 이는 여러 경우의 시나리오를 간략하해 묘사하면 아키텍처의 경계를 발견할 수 있다.

### 결론

- 아키텍처 경계가 어디에나 존재한다. 우리는 경계가 언제 필요한지를 신중하게 파악하면 된다.
- 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 것도 알아야한다.
    - 하지만 무시한다면 다시 추가하는 비용이 더 커진다.
- YAGNI(You Aren't Going to Need It). 오버엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.
- 다른 한편으로는 어떤 아키텍처 경계도 존재하지 않는 상황에서 경계가 정말로 필요하다는 사실을 발견한 후 그때서야 경계를 추가하려면 비용이 많이 들고 큰 위함을 감수해야 한다.
- 목표를 달성하려면 빈틈없이 지켜봐야 한다.

## 26장 메인(Main) 컴포넌트

모든 시스템에는 최소한 하나의 컴포넌트가 존재하고 이 컴포넌트가 나머지 컴포넌트를 생성하고 조정하며 관리한다. 이것을 메인(Main) 컴포넌트라 부른다.

### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로 **가장 낮은 수준의 정책이다**. 메인은 시스템의 초기 진입점이다.
- 메인은 모든 팩토리와 전략, 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 맡는다.
- 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다. (???)
- **메인은 클린 아키텍처에서 가장 바깥 원에 위치하는 지저분한 저수준 모듈이라는 점이다.**
    - 메인은 고수준의 시스템을 위한 모든것을 로드한 후 제어권을 고수준의 시스템에게 넘긴다.
- 메인을 애플리케이션의 플러그인이라고 생각하자
    - 메인을 플러그인 컴포넌트로 여기고, 그래서 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

## 27장 ‘크고 작은 모든’ 서비스들

- 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.
    - 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고는 볼 수 없다.
- 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다. 아키텍처적으로 중요한 서비스도 있지만, 중요하지 않은 서비스도 존재한다. 이 장에서는 전자인 관점에서 본다.

### 서비스의 이점

### 결합 분리의 오류

- 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다. 대신 서비스는 서로 다른 프로세스에서, 직접 변수에 접근할 수 없고, 인터페이스는 잘 정의되어있어야 한다.
    - 하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합 될 가능성이 여전히 존재한다.

### 개발 및 배포 독립성의 오류

- 서비스를 사용함에 따라서 갖는 이점 중 또 하나는 전담팀에서 각 서비스를 작성하고 유지보수하며 운영하는 책임을 질 수 있다.
    - 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.
    - 하지만 극히 일부이다.
        - 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실은 역사적으로 증명되어왔다.
        - 데이터나 행위에서 어느정도 결합되어있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.

### 야옹이 문제

이전 9장 택시 통합 시스템 예시를 다시 가지고와서 확장 가능한시스템을 구축하고싶었기에 수많은 작은 마이크로 서비스를 기반으로 구축하기로 결정했다.
<img width="1000" alt="2" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/2513e44a-68c8-4204-87f3-9efc04a4db45">

- 이 서비스 다이어그램대로 서비스를 운영하다가 야옹이 서비스를 시작한다면 택시 업체 한곳이 추가로 들어가고 세부적인 필터를 적용해 배차를 해야한다는 등 추가, 변경 기능이 있게 된다면 거의 전부를 변경해야 한다.
    - 다시말해 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고 배포하거나 유지될 수 없다.
    - 이게 바로 횡단 관심사가 지닌 문제다. 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면하게 마련이다.
    - 이렇게 묘사괸것과 같은 종류의 기능적 분해는 새로운 기능이 기능적 행위를 횡당하는 상황에 매우 취약하다

### 객체가 구출하다

- 컴포넌트 기반 아키텍처에서는 SOLID 설계 원칙을 적용하는데, 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함을 알 수 있다
<img width="1000" alt="3" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/30034a83-832a-46fc-8bb2-7c17b841b22d">


- 경계와 의존성 규칙을 준수하는것을 볼 수 있다.
- Rides / Kittens 컴포넌트로 나누고 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드 한다.
- 이 전략을 따르더라도 야옹이 기능을 구현하려면 TaxiUI는 어쩔수 없이 변경해야만 하지만 그 외의 것들은 변경할 필요가 없다.
- 즉 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.

### 컴포넌트 기반 서비스

- 서비스에도 컴포넌트 기반 서비스를 만들수 있다. 서비스가 소규모 단일체일 필요는 없다.
<img width="1000" alt="4" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/c0191cd0-0265-4220-9a33-b19549c4ec87">

- 이전 예에 이어가면서 서비스들의 존재는 이전과 달라진게 없지만 각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다. 파생 클래스들은 각자의 컴포넌트 내부에 놓인다.

### 횡단 관심사
<img width="1000" alt="5" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/f59ca575-d81c-45e0-ae62-e7ceee544568">

- 아키텍처 경계가 서비스 사이에 있지 않다는 사실이다. **오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.**
- 횡단 관심사를 처리하려면 아래 다이어그램에서 보듯이, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
- 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.

### 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.
- 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.
