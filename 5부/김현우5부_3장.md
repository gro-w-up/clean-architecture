# 23. 프레젠터와 험블 객체

## Q: 험블 객체란 무엇인가?
`험블 객체 패턴`은 행위를 테스트하기 어려운 부분과 쉬운 부분으로 나누는 패턴이다.
이 중에서 테스트하기 어려운 부분을 `험블 객체`라고 부른다.

> 복잡한 로직이나 의존성을 가진 부분과, 테스트가 어려운 부분(예를 들어, 파일 입출력, 네트워크 통신 등)을 분리하여<br>
> 최대한 많은 부분을 테스트 가능하게 만드는 것이 목적입니다.
{:.lead}

## Q: 왜 험블 객체 패턴을 사용해야 하는가?

험블 객체 패턴을 사용해서 코드의 테스트 용이성을 높이고, 최대한 많은 코드를 외부 위협 없이 테스트할 수 있다.<br>
이런 노력은 결국 시스템의 안정성을 증가시키는 방향으로 발전한다.<br>
## **클린 아키텍처**에서 `경계`란 무엇인가?

시스템 내에서 도메인 로직과 외부 요소(예를 들어, 입출력, 네트워크 통신, 데이터베이스 등)가 만나는 지점을 의미한다.
험블 객체 패턴을 사용하여 아키텍처의 경계를 더욱 명확히 식별하고 보호할 수 있다.

### 경계 보호의 이점
* **테스트 용이성:** 험블 객체 패턴을 통해 경계를 구분하면, 도메인 로직을 담고 있는 부분은 쉽게 테스트할 수 있다. 이로써, 높은 코드 커버리지와 안정성을 달성할 수 있다.
* **유지보수성:** 시스템의 한 부분을 수정할 때 다른 부분에 미치는 영향을 최소화할 수 있다.
* **코드의 명확성:** 경계가 명확하면, 코드를 읽고 이해하는 데 있어 그 목적과 역할이 뚜렷해진다. 이는 코드의 가독성과 명확성을 높여준다.

흠.. 그럼 험블 객체는 아키텍처의 경계에서 안정성을 위해 분리된 `구체적이고 테스트가 힘든 저수준 계층의 객체`인가보다. Ex) DB SQL 직접 접근 레포지토리 구현체
예시로 코드를 하나 짜보자.


![김현우_험블.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%ED%97%98%EB%B8%94.png)
Usecase - Gateways - DB를 예시로 짜보자
{:.figcaption}

Usecase와 DB 사이에는 Gateways가 존재한다.<br>
Usecase는 SQL의 S자도 모른다. 그냥 Gateway Interface에게 요청하고, Gateway는 적절한 DB에 맞춰 구현체를 생성하여 요청에 응한다.<br>


~~~java
// Usecase
public interface UserLoginDataUseCase {
    User[] getUserLoginData(Date startDate, Date endDate);
}

// UsecaseImpl
public class UserDataService implements UserLoginDataUseCase {
    private DatabaseGateway databaseGateway;

    public UserDataService(DatabaseGateway databaseGateway) {
        this.databaseGateway = databaseGateway;
    }

    @Override
    public User[] getUserLoginData(Date startDate, Date endDate) {
        return databaseGateway.getLastNamesOfUsersWhoLoggedInBetween(startDate, endDate);
    }
}

// DatabaseGateway (테스트 가능)
public interface DatabaseGateway {
    User[] getLastNamesOfUsersWhoLoggedInBetween(Date startDate, Date endDate);
}

// Database (테스트 어려움)
public class Database implements DatabaseGateway {
    @Override
    public User[] getLastNamesOfUsersWhoLoggedInBetween(Date startDate, Date endDate) {
        // DB 접근
        return null;
    }
}

~~~

* 로그인 유저에 대한 데이터를 가져오는 Usecase를 만들었다.<br>
* Usecase는 DatabaseGateway를 통해 데이터를 가져온다.<br>
* DatabaseGateway는 Database를 구현한 구현체를 통해 데이터를 가져온다.<br>
* Database는 실제 DB에 접근하여 데이터를 가져온다.<br>

아키텍처의 경계마다 험블 객체 패턴을 적용하면, 테스트 가능한 코드와 테스트 어려운 코드를 분리할 수 있다.<br>
경계를 넘나드는 통신은 모두 간단한 데이터 구조를 수반할 때가 많고,<br>
대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다.<br>


이 구조를 사용하면, 테스트 가능한 DatabaseGateway를 테스트 더블로 대체하여 UserDataService의 테스트가 용이해진다.<br>
{:.note}



## Q: 그럼 JPA같은 ORM은 어디에?

하이버네이트같은 ORM은 Infra Adapter Layer인 데이터베이스보다 안쪽에 속한다.<br> 
즉, Gateway Interface와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다.<br>

저자는 ORM(객체 관계 매퍼)는 사실 존재하지 않는다고 말한다.
{:.lead}

> ORM은 객체와 관계형 데이터베이스 사이의 매핑을 의미한다.<br>
> 그런데 객체지향 프로그래밍과 관계형 데이터베이스는 본질적으로 다른 패러다임을 가진다.<br>

이런 "객체-관계 불일치" 문제는 ORM을 사용하더라도 완전히 해결되지 않는다.<br>
그래서 객체-관계 매퍼보다 `데이터 매퍼` 로 부르는 편이 낫다고 한다.
관계형 데이터베이스 테이블로부터 가져온 데이터를 구조에 맞게 담아준다고 보기 때문이다.

| 특성            | 객체 (Object-Oriented)       | 관계형 데이터베이스 (RDBMS)  |
|-----------------|----------------------------|-----------------------------|
| 데이터 저장 형태 | 클래스와 인스턴스                  | 테이블과 레코드             |
| 캡슐화          | 변수 캡슐화하여 <br/>Operation 집단 | 상태만 저장                  |
| 상속            | 지원 (클래스 상속)                | 일반적으로 지원하지 않음     |
| 다형성          | 지원                         | 지원하지 않음                |
| 데이터 접근     | 객체 메서드를 통해 접근              | SQL 쿼리를 통해 접근        |
객체와 관계형 데이터베이스의 차이
{:.figcaption}


저자는 JPA의 Entity와 순수 도메인객체와의 분리를 하는 것을 염두에 둔 듯 하다.<br>
JPA의 Entity는 단순히 RDB의 테이블 데이터를 매핑해 가져와주는 객체라고 생각이 든다.(설득됐다)<br>







#24. 부분적 경계

처음부터 아키텍처의 모든 구조를 설계해놓고 사용할 순 없다. 아키텍처는 점진적으로 발전해야 한다.<br>
그렇다고 처음부터 전부 단일 컴포넌트에 넣고 설계를 시작할 수는 없는 노릇이다.<br>

아키텍처의 완벽한 경계들을 생성하고 유지하는데 많은 비용이 든다.<br>

> 저자는 아래와 같은 비용이 든다고 말했다. <br>
> <br>
> -쌍방향의 다형적 Boundary 인터페이스 (경계를 넘나드는 통신을 위한 인터페이스)<br>
> -Input과 Output을 위한 데이터 구조<br>
> -두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는데 필요한 의존성 관리 노력<br>

완벽한 설계로 시작을 하면 비용이 많이 들고 개발 속도가 늦어진다. 근데 완벽한 경계를 만들지 않으면, 나중에 경계를 만들기가 어려워진다.<br>

그럼 어떻게 하지? 부분적 경계로 만들어보자!<br>
{:.lead}

그래서 완벽한 경계를 구성하여 모두 분리하는 것이 아닌, 확장성이나 추후 완벽한 경계를 염두에 둔 채 부분적 경계를 구성하는 방법이 있다.<br>
다음의 `세 가지` 부분적 경계를 선택한 방법을 보자. 각 방법은 명확한 장점과 단점이 있다.<br>



## 마지막 단계를 건너뛰기

독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 채, 이들을 하나의 컴포넌트에 그대로 모아두는 것이다.<br>

개발은 경계적으로 나눠서 진행하고 `컴포넌트 분리`를 건너뛰는 것이다.


* 장점
  * 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다. 배포에 대한 관리 부담도 없다.
* 단점
  * 결국 완벽한 경계를 만들 때와 동일한 코드량과 사전 설계가 필요하다.
  * 추후에 컴포넌트가 발전되고, 드디어 분리될 시기에 많은 노력이 필요하다.

개인적인 의견으로는 추후에 필요에 의해 발전된 코드를 컴포넌트별로 분리하는 노력보다<br>

어차피 설계부터 완벽한 경계와 같은 노력이 든다면 그냥 분리해서 만드는게 맘이 더 편하지 않을까 싶다.<br>
어차피 `오버엔지니어링`의 위험은 동일한 것 같다.<br>
{:.faded}

## 일차원 경계

기존 완벽한 경계를 유지하기 위해서는 아래와 같이 양방향 (In/Out)으로 격리된 Boundary Interface를 사용한다.<br>

![김현우_일차원경계.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EC%9D%BC%EC%B0%A8%EC%9B%90%EA%B2%BD%EA%B3%84.png)
기존 IN/OUT 으로 나뉜 양방향 Interface
{:.figcaption}

초기 설정이나 지속적으로 유지할 때 비용이 많이 든다.<br>
클래스나 인터페이스의 개수가 많아지고, 결국 무언가 추가하고 싶은 경우에 고려해야 할 사항이 많아진다는 의미다.<br>

---

![김현우_일차원경계_2.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EC%9D%BC%EC%B0%A8%EC%9B%90%EA%B2%BD%EA%B3%84_2.png)
하나로 묶인 Boundary Interface
{:.figcaption}

In/Out으로 구분하지 않고 더 간단하게 Interface 바운더리를 축약하는 것이다.<br>


* 장점
  * 의존성 역전으로 구분은 해뒀기 때문에 미래에 분리시에 상대적으로 간편하다.
* 단점
  * ServiceImpl이 바로 Client를 참조하는 비밀통로를 가지고 있기 때문에, 쉽게 붕괴될 가능성이 있다.

이는 기존에 많이 사용되고 있는 방식이다.<br>

첫 직장에서 `Service를 왜 Interface로 빼는 바보같은 반복작업을 시키는거지?` 라는 궁금증이 있었던 적이 있어서 웃음이 난다.<br>
{:.note}

## 퍼사드 패턴

### Q: 퍼사트 패턴이란?

`Facade`라는 단어의 뜻은 건축물의 정면을 의미한다.<br>

내가 퍼사드 패턴을 정확하게 이해했던 예시는 컴퓨터이다.<br>
{:.lead}

>컴퓨터 사용자는 내부의 모든 구조를 알지 않아도 본체와 모니터, 키보드와 마우스만 알면 컴퓨터를 사용할 수 있다.<br>
>CPU객체, 램 객체, 메인보드 어쩌구 저쩌구는 모두 본체라는 퍼사드를 통해 사용자에게 제공된다.<br>
>우리는 본체의 전원 메서드만 실행시키면 내부의 복잡한 로직을 몰라도 컴퓨터를 사용할 수 있게 된다.<br>

![김현우_퍼사드.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%ED%8D%BC%EC%82%AC%EB%93%9C.png)
7살때부터 스타크래프트를 했던 나는 
이미 퍼사드구조를 적극 사용중이었다.
{:.figcaption}


클린아키텍처에서 퍼사드 패턴은 의존성 역전까지도 희생한다.<br> 
경계는 퍼사드 패턴으로 간단희 정의된다. 클라이언트는 퍼사드만 알고 있다.<br>

하지만 클라이언트가 퍼사드를 보고 있고, 퍼사드는 모든 서비스에 대한 의존성을 가지고 있기 때문에<br>

이는 결국 클라이언트도 모든 서비스에 대해 추이 종속성을 가지게 된 것이다.흑흑<br>
{:.faded}


---

# 24장 마치며

세상의 모든 것은 trade off, 등가교환, 저울질이니...정답은 없다니 심란하다.<br>
{:.faded}

```
                                     .-===-.
                                      \   /
                                      |   |
                                    __|:::|__
       .-===-.                 _.--'  |:::|  `-._
        \   /           __    /      (:::::)     \
        |:::|          |  |   \       `---'      /
      __|:::|__        |..|    ``--...____...--''
 _.--'  |:::|  `-._   /_/\_\     ___..-(O/
/      (:::::)     \  |  __...--' __..-''
\       `---'      /_.--(o)_...--'
 ``--...____...--''__..--'_|
        \O)___..--'   \ \/ /
         .-------------|''|-------------.
        /              |__|              \
       /__________________________________\
       '----------------------------------'
```
trade off
{:.figcaption}







# 25. 계층과 경계

아키텍처에서 계층과 경계를 만든다는 것은 비용이 큰 일이라고 했다.<br>
그렇다고 경계를 무시하고 만든다면, 나중에 다시 추가하는 비용은 더욱 크다.<br>

그래서 나보고 어떻게 하라고?..
{:.lead}

`계층과 경계를 만드는 일은 비용이 많이 든다`는 경각심을 가지고, 우리는 아키텍처 경계가 언제 필요할지 신중하게 파악해야 한다.<br>
너무 미리 경계를 정의해 추상화 하는 것은 `오버 엔지니어링`이다.<br>
대부분의 경우 과한 것 보다 모자름이 낫다. 이 아키텍쳐 설계에서도 예외는 아닌가보다.<br>

![김현우_과유불급.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EA%B3%BC%EC%9C%A0%EB%B6%88%EA%B8%89.png)
명심 또 명심~
{:.figcaption}


우리는 설계를 단발적으로 생각하는 경향이 있다. 건축과 비유를 많이 해서 그럴 수도 있다.<br>
건물은 한 번 올라가면 수정이 어렵다. 그러나 다시 처음으로 돌아가 생각해보면 `Software Architecture`는 지속적인 수정이 핵심이다.<br>
프로젝트 초기부터 차근차근 아키텍처를 성장시켜 나가는 것이 중요하다.<br>
육아는 쉬운일이 아니듯이, 아키텍처를 올바르게 키우기 위해서는 지속적인 관심과 사랑이 필요하다.<br>

> 훌륭한 아키텍트로써 미래를 내다보고 현명하게 추측해야 한다.<br>
> 
> 비용을 산정하고, 경계를 어디에 둘 것인지, 완벽히 구현할 경계는 어디고 부분적 경계를 할 곳은 어딘지,<br>
> 오버엔지니어링 쉐도우 복싱은 아닌지, 변경이 될 것 같은데 지나친 부분은 없는지<br>
> 꾸준히 프로젝트가 진행되고 소스코드가 추가되고, 구조가 추가될 때 마다 고려해야 한다.<br>

모두를 위해 봉사하지만 그림자속에 존재하는 고담시의 다크나이트가 생각난다...
{:.faded}


## 게임을 예시로 변화하는 설계 예시
그럼 지금부터 `클린 아키텍처`에서 나오는 `아키텍트라는 다크나이트`가 무슨 고민을 해야 하는지 예시로 알아보자.<br>
저자는 [움퍼스 사냥](https://en.wikipedia.org/wiki/Hunt_the_Wumpus) 이라는 게임을 예시로 들었다.<br>

![김현우_움퍼스.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EC%9B%80%ED%8D%BC%EC%8A%A4.png)
70년대 시작된 게임
{:.figcaption}

### 1. 제일 컴팩트한 설계

단순히 동아리방에서 친구들끼리 할 게임을 설계해서 만든다고 생각해보자.<br>
이동, 공격 등 단순한 기능을 가진 단일 컴포넌트로 200줄짜리 코드뭉치로도 가능할 것이다.<br>


### 2. 언어적, 데이터적 경계 추가

우리가 게임이 성공해서 각 국가별로 확장하고, 데이터 저장소를 분리한다고 생각해보자.<br>
이런 경우에는 언어적 경계와 데이터적 경계를 추가해야 한다.<br>
Game의 핵심 Rules(불변) 을 추출해서 중심을 구성하고, In(언어적), Out(데이터 저장) 으로 분리해본다.<br>

![김현우_언어데이터경계추가.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EC%96%B8%EC%96%B4%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%BD%EA%B3%84%EC%B6%94%EA%B0%80.png)
단순 경계 구성
{:.figcaption}

### 3. 지원 매체 확장

사업이 더 잘되어서 콘솔이 아니라 모바일 시장을 점령하면 어떻게 할건가?<br>
그래서 우리의 게임 지원 모델을 더 확대해봤다.<br>
점선은 Interface(다형성) 객체이다.<br>

![김현우_개선된다이어그램.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EA%B0%9C%EC%84%A0%EB%90%9C%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8.png)
본격적으로 개선된 아키텍처
{:.figcaption}

이제 우리는 핵심 도메인인 GameRules를 필요에 따라 영어, 스페인어 등으로 지원이 가능하다.<br>
그리고 그 언어별로 전달되는 구현객체는 SMS, Console로 선택할 수 있다.<br>
저장소는 Cloud 혹은 Flash 메모리에 저장할 수도 있다.<br>

![김현우_단순화된다이어그램.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EB%8B%A8%EC%88%9C%ED%99%94%EB%90%9C%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8.png)
Client -> TextDelivery -> Language -> GameRules -> Storage
{:.figcaption}

요청 IN / OUT과 계층으로 나누면 위와 같은 그림이 나올 것이다. 계층이 잘 나뉘어져 있다.<br>

### 4. 온라인으로 바뀌면?

개인 플래이가 아니라 멀티유저가 사용하게 된다면 어떻게 될까?<br>
네트워크 컴포넌트가 추가되어야 한다.<br>

![김현우_네트워크흐름추가.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%9D%90%EB%A6%84%EC%B6%94%EA%B0%80.png)
네트워크 흐름 추가
{:.figcaption}

### 5. 게임이 더 커지면?

단순 Game Rules로 처리할 수가 없을 것 같다. 우리의 게임은 세계적인 게임이 되어서 모든 게임을 지배할것이다.<br>
그러므로 `MSA`로 구축하고 사용자의 이동 관리는 고객의 컴퓨터에, 실제 사용자들은 서버에서 분리하여 관리하면 좋겠다.<br>
![김현우_마이크로.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C.png)
동아리 방에서 오버하지 말라가 절로 나오는 설계다
{:.figcaption}


## 마무리

동아리 방에서 200줄짜리 코드에서 전 세계적인 서비스를 염두에 두기까지 어떤 생각이 들었는가?<br>
이런 고민을 하면서 아키텍처를 설계하는 것이 아키텍트의 일이다.<br>
어디까지가 오버고 어디까지가 언더인가..<br>

많은 경험과 고민이 필요한 일인 것은 분명하다.<br>
{:.lead}

![김현우_GTPT.png](resources%2F%EA%B9%80%ED%98%84%EC%9A%B0_GTPT.png)
chatGPT는 T인게 분명하다
{:.figcaption}



## 26. 메인(Main) 컴포넌트

저자는 `메인 컴포넌트`가 나머지 컴포넌트를 생성하고 조정하며 관리한다고 했다.<br>
메인 컴포넌트는 가장 세부적이고 낮은 수준의 정책이다. <br>

#### ✒︎  Q: 왜 메인이 가장 저수준이지?.. 설계도상 항상 맨 위에 있는데
그림과 헷갈리면 안된다. 아키텍처의 핵심은 애플리케이션의 '비즈니스 로직' 혹은 '도메인 로직'을 극대화하는 것이다.<br>
나머지는 그저 비즈니르 로직을 구현하기 위한 구체화 도구로 생각하면 된다.<br>
`핵심 비즈니스 로직`은 애플리케이션의 가장 '높은' 수준의 정책을 나타내고, <br>
이렇게 정의되는 '높고 낮음'의 척도는 단순히 코드의 실행 순서나 프로그램의 구조를 나타내는 것이 아니라, 어떤 것이 더 '중요한가', '변경될 확률이 낮은가'에 대한 척도라고 보면 된다.<br>


> 메인은 시스템의 진입을 유도한 후에 고수준의 부분으로 제어권을 넘기는 역할을 맡는다.<br>
> 메인을 아키텍처 경계 바깥의 플러그인들과 동일시하여 생각하면 쉽다.<br>
{:.lead}

---

## 27. '크고 작은 모든' 서비스들

요즘 유행하는 **서비스 지향 아키텍처**와 **마이크로서비스 아키텍처**는 서비스를 중심으로 `분리`되어 있다.<br>

![서비스지향아키텍처](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/37a32a31-ccdf-4fbc-a977-3b7132a01b72){:.centered}{: width="700"}
저자가 말한 단순 서비스분리 아키텍처이다. <br>
기능적 관점에서만 분리해 새 기능이 추가될 경우, 기능 횡단적 관심사 분리가 안되어 수정시 전체수정을 해야한다.
{:.figcaption}

#### ✒︎  Q: SOA의 서비스와 저자의 컴포넌트의 차이

들어가기에 앞서, 27장에서 나오는 저자의 서비스라는 용어의 조작적 정의가 뭘까 고민해봤다.<br>

두 개념은 비슷해 보이지만, 사용 목적과 범위, 그리고 의존성과 연계성 등에서 차이가 있다.<br>
SOA의 서비스는 대개 시스템 간의 상호작용을 목적으로 `분리`에 초첨이 맞춰져 있다.<br>
클린 아키텍처의 컴포넌트는 보통 하나의 애플리케이션 내부에서의 모듈화와 재사용성을 목적으로 한다.<br>

저자는 `단순 기능 중심으로 분류되기만 한 제한된 서비스`라는 정의를 내려 컴포넌트와의 차이점을 드러내고,
클린 아키텍처의 `경계` 구분의 핵심은 기능 위주가 아니라 컴포넌트의 의존성에 있다고 말하는 것 같다.<br>


#### ✒︎  Q: 유행중인 두가지 아키텍처는 클린 아키텍처와 부합될까?
저자는 두 아키텍처의 포커싱을 단순히 `서비스`로 둔다면, 클린 아키텍처와 부합하지 않는다고 한다.<br>
{:.lead}
* 상호 **결합**이 철저하게 분리되는 것처럼 보인다.
* **개발과 배포 독립성**을 지원하는 것처럼 보인다.

서비스 중심으로 분리하는 것이, 결합도와 개발/배포 독립성이 높아지는 것을 완벽히 보장되지 않는다.<br>

* 서비스는 분리된 코드나 기능을 제공하며, 이는 '횡단 관심사'를 일으킬 수 있다.
* 서비스의 분리는 단순히 '값비싼 함수 호출'에 불과할 수 있으며, 이 자체로 아키텍처를 결정짓지는 않는다.

---

### 🌟`서비스 분리가 클린 아키텍처가 될 것이다` 가 잘못된 생각인 이유

단순히 서비스를 분리하면 결합도가 낮아지는 장점은 있다.<br>
그러나 이것은 단순히 소규모의 `변수` 단위에서 이뤄지는 결합 분리이다.<br>
결국에 서비스 간의 결합이 코드 수준에서는 잘 분리되어 있을지라도, 공유되는 자원(예: 데이터베이스) 때문에 실질적으로는 강한 결합을 가질 수 있다.<br>
이러한 강한 결합은 시스템이 변화할 때 모든 서비스에 영향을 줄 가능성이 높아진다.<br>
예를 들어, 공유된 데이터베이스의 테이블 컬럼이나 스키마가 변경되면, 이에 의존하는 모든 서비스가 수정되어야 할 수 있다.<br>

#### ✒︎  서비스 분리 결합도 문제의 본질
이것이 바로 **'횡단 관심사(Cross-Cutting Concerns)'**에 대한 문제이다.<br>
하나의 변경이 전체 시스템에 미치는 영향이다. 이러한 횡단 관심사를 잘 관리하지 못하면, 서비스는 물리적으로는 분리되어 있지만 논리적으로는 강하게 결합되어 있는 상태가 된다.<br>

>  서비스 중심 아키텍처에서 여러 서비스가 공유 자원(예: 데이터베이스, 메시지 큐 등)에 대한 의존성을 가질 경우, 이러한 공유 자원이 바로 횡단 관심사가 된다.<br>
> 예를 들어, 한 서비스에서 데이터베이스의 특정 테이블을 수정하면, 그 변경 사항은 다른 서비스에도 영향을 줄 수 있다.<br>
> 이렇게 되면 서비스들 사이에 간접적인 결합이 발생하게 된다.<br><br>
> 이러한 간접결합은 시스템 전체에 대한 복잡성을 증가시키며, 변경이나 확장을 어렵게 만든다.<br>
> 따라서 횡단 관심사를 잘 관리해야만 이러한 간접결합을 최소화하고, 각 서비스가 독립적으로 유지보수와 확장이 가능하도록 할 수 있다.<br>
{:.lead}


#### ✒︎  개발과 배포 독립성 문제의 본질
서비스중심으로 분리함에 따라 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영하는 것이다.<br>
각 서비스는 전담팀이 작성하고 유지보수하며, 운영하는 책임을 질 수 있게 된다.<br>
그리고 이게 개발 및 배포 독립성이 확장 가능한 것으로 간주하는 이유이고 독립적인 팀 단위별로 서비스를 맡아 책임질 수 있게 된다.<br><br>

**저자는 이것의 극히 일부만 인정한다.**<br>

1. 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 외에 모노리틱, 컴포넌트 기반 시스템으로도 구축 가능하다.<br>
2. 서비스라고 해서 항상 독립적으로 개발,배포,운영이 가능한 것은 아니다. 데이터나 행위에서 어느정도 결합되면 결합된 정도에 맞게 조정해야 한다.<br>



횡단관심사 해결에는 계층별 DTO 분리, CQRS, Event주도 개발로 횡단 관심사를 분리하는 방법이 있다.<br>
{:.note}


---

그렇다면 무엇이 중요한가?<br>
{:.lead}

중요한 것은 서비스 자체가 아니라 어떻게 서비스가 시스템 전체와 연결되어 있는가 <br>
즉, 서비스 내에 그어진 경계와 경계를 넘나드는 '의존성 규칙'을 어떻게 준수하고 있는가이다.<br>
아키텍처는 시스템의 **고수준 정책과 저수준의 세부사항을 분리하는 경계**에 의해 정의된다.<br>
의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출이 아키텍처를 정의하는 요소이다.<br>

> `결국 변경시에 얼마나 힘든가`가 척도이다.
{:.lead}

### 🌟컴포넌트 기반 아키텍처에서 횡단적 관심사를 분리하는 방법

다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.

![컴포넌트기반에서설계](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/ae2f8881-4878-43d6-9060-ae49d0980b9c){:.centered}{: width="700"}
컴포넌트 기반의 아키텍처에서 설계한 모습
{:.figcaption}

주요한건 경계가 생기고, 다형성으로 의존도를 낮추고, 횡단 관심사를 분리한다는 것이다.<br>
추상체와 구현체가 분리되어 필요에 따라 구현체를 다형성을 이용해 교체 가능하다.<br>
TaxiFinder, Selector 등의 종류가 추가되더라도 새로운 컴포넌트를 추가하고 구현하기만 하면 된다.<br>
이후 UI에서 받아 ComponentFactories에서 생성의뢰를 맡기면 된다.<br>


### 🌟그럼 서비스기반에서도 가능할까?

YES! 가능하다.
{:.lead}

서비스는 SOLID 원칙대로 설계 가능하며, 컴포넌트 구조를 갖출 수도 있다.<br>
서비스의 범위는 `하나 이상의 jar 파일에 포함되는 추상 클래스들의 집합`이다.<br>
jar를 추가하고 구현체들을 만들어 확장을 하면 된다.

![서비스컴포넌트설계](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/4053066e-910f-41c5-8477-5971f51f58a7){:.centered}{: width="700"}
이전의 서비스 설계와 달리 추상체로 Service를 만들고, 필요에 의해 구현체를 만들어 사용한다.
{:.figcaption}


### 🌟 아키텍처의 경계는 서비스에 있지 않다.

지금까지 결국 클린 아키텍처의 중요 포인트인 `경계`는 결국 서비스 사이에 있지 않다는 것을 길게 설명했다.<br>
아키텍처의 경계를 결정하는 것은 서비스 내에 위치한 컴포넌트들이다.<br>

서비스는 개발하거나 확장할 때 유용하긴 하지만, 아키텍처에서는 큰 역할을 하지 않는다.<br>
아키텍처를 결정하는 건 시스템 내부에서 어떻게 의존성이 연결되는가이다.<br>
서비스는 하나의 '경계' 안에 있을 수도 있고, 여러 '경계'로 분리된 다수의 컴포넌트를 뭉쳐 만들 수도 있다.<br>


![서비스내부아키텍처설계](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/c42d49e5-f591-4024-b675-1a93ac0c1738){:.centered}{: width="700"}
의존성 규칙을 준수한 서비스 컴포넌트식 설계
{:.figcaption}

아키텍처의 경계는 서비스가 아니다.
{:.note}





## 28. 테스트 경계

테스트는 아키텍처의 일부이다. 테스트를 설계의 영역으로 넣지 않고 잘못 짠다면 깨지기 쉽고 유지보수가 어려워진다.<br>
수정 한 번에 테스트 1000개씩 어긋나기 시작하면 수정이 점점 두려울 것이고, 테스트는 더 이상 도움이 되지 않는다.<br>

테스트는 태생적으로 의존성 규칙을 따르는데, 테스트가 아키텍처 원 제일 외부에 있다고 생각하면 의존성은 항상 내부로 향한다.<br>
그래서 테스트를 고려하지 않고 설계하면 아래와 같아진다.
* 테스트가 깨지기 쉬워지고 시스템은 뻣뻣해져서 변경이 어렵다.
* 테스트가 시스템에 강하게 결합된 탓인데, 시스템이 변경되면 테스트도 함께 변경되어야 하는 단점이 있다.
* 시스템에서 생긴 변화에 예민해지면 테스트가 순식간에 어긋난다.
* 개발자들은 수정에 두려움을 갖기 시작한다.

테스트는 값비싼 자원(DB,UI)은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하여야 한다.<br>
{:.lead}

---

## 29. 클린 임베디드 아키텍처

하드웨어의 발전 속도는 대단하다.<br>
![무어의법칙](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/446ec62d-dbfe-46c9-80fd-3f77a5d19caa){:.centered}{: width="600"}
굳이 증명하지 않아도 [무어의법칙](https://ko.wikipedia.org/wiki/%EB%AC%B4%EC%96%B4%EC%9D%98_%EB%B2%95%EC%B9%99)은 다들 들어봤을 것이다.<br>
하드웨어에 결합되게 소프트웨어를 설계하면, 하드웨어가 발전하면서 소프트웨어를 다시 설계해야 한다.<br>
저자는 이런 교체되어야 하는 강결합 소프트웨어도 [펌웨어(firmware)](https://ko.wikipedia.org/wiki/%ED%8E%8C%EC%9B%A8%EC%96%B4)라고 부른다.(딱딱해)<br>

`켄트 백(Kent Beck)`과 저자에 따르면, 아래 세 가지 활동을 통해 소프트웨어를 설계해야 한다고 한다.<br>
> 1. 먼저 동작하게 만들어라.<br>
     > -> 소프트웨어가 동작하지 않는다면 사업은 망한다.
> 2. 그리고 올바르게 만들어라.<br>
     > -> 코드를 리팩터링해서 당신을 포함한 나머지 사람들이 이해할 수 있게 만들고, 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라.
> 3. 그리고 빠르게 만들어라.<br>
     > -> 코드를 리팩터링해서 '요구되는' 성능을 만족시켜라.

그런데 보통은 올바르게 만들어라 (유지보수와 이식도가 높은 클린 아키텍처로 만드는 방향인 것 같다.) 를 지키지 않는다고 한다.<br>

```yml

    [소프트웨어]
      [OSAL]
       [OS]
      [HAL]
      [펌웨어]
     [하드웨어]
```

임베디드 소프트웨어도 하드웨어,OS와의 결합도를 낮추고 추상화를 진행해야 한다고 얘기한다.<br>
하드웨어 자체는 소프트웨어 아키텍처 입장에서는 선택사항이므로 최대한 최후의 결정되는 시점까지 미뤄진다.<br>
그러므로 하드웨어와의 결합도를 낮추는 것이 중요하다.<br>
하드웨어는 어찌됐건 가장 경계 바깥에 최최최말단에 존재한다고 보면 된다.<br>






---

## 출처

[27장 그림 출처](https://hwannny.tistory.com/46)
