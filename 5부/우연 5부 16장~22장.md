# 5부 16장. 독립성

### 좋은 아키텍처

- 시스템의 유즈케이스 지원
- 시스템의 운영이 고려된 아키텍처
- 시스템의 독립적 개발
- 시스템의 즉각적인 배포

### 유즈케이스

- 시스템이 지닌 의도를 아키텍처 수준에서 알아 볼 수 있도록 만드는 것이다.
    - 🧐 MVC Model2 Architecture의 Controller 역할?

🧐 일급 요소 (=일급 컬렉션)?

- 데이터의 불변을 보장하기 위해서 사용

### 운영

- 컴포넌트를 적절하게 격리하여 유지
- 컴포넌트 간 통신 방식을 특정 형태로 제한

### 개발

- 컴포넌트는 독립적으로 개발되어야함.
- 그러려면 팀별로 관심사별로 묶어 서로 방해 받지 않도록 해야한다.

### 배포

- 컴포넌트 단위의 즉각적인 배포가 가능해야한다.

### 선택사항 열어놓기

- 제곧내
    - 선택 사항(외부 관심사들의 균형)을 닫아두면 향후 시스템 변경이 어렵다.

### 계층 결합 분리

- 수직 수평으로 분리했을 때, 맨 아래 계층(데이터베이스) 까지 모두 각 계층에서 겹치지 않게해야한다.

--- 

# 5부 17장. 경계: 선 긋기

- 소프트웨어 아키텍처는 “선을 긋는 기술” 이러한 선을 **경계**라고 부른다.
- 일찍 내려진 결정(프레임워크 B B,버 ,서버 ,이브러리, 의존성)에 따른 결합에 따라 인적 자원의 효율이 떨어진다

### 결론

경계선을 그리려면 컴포넌트 단위로 분할해야한다.

---

# 5부 18장. 경계 해부학

### 경계 횡단하기

적절한 위치에서 경계를 횡단하게 하는 비결은 소스코드 의존성 관리에 있다.

> 소스코드 모듈 하나가 변경되면 의존하는 다른 소스코드 모듈도 변경하거나 다시 컴파일해서 배포해야할 수도 있기 때문이다.
> 

### 두려운 단일체

`단일체` : Monolithic

🧐 **동적 다형성 (Dynamic Polymorphism)**

- 동적 다형성은 마치 서로 다른 모양의 퍼즐 조각들을 모아서 크고 아름다운 그림을 만들어내는 것과 비슷합니다. 각 퍼즐 조각은 다양한 모양과 크기를 가지고 있지만, 모두 함께 조립하여 아름다운 그림을 만들 수 있습니다.
- ex. 동물들을 나타내는 다양한 객체(개, 고양이, 새)가 있을 때, 이 객체들을 모두 "소리를 내다"라는 행동을 할 수 있게 만들 수 있습니다. 이것은 마치 동물들이 함께 노래를 부르는 것과 비슷합니다. 이때 "소리를 내다"라는 행동은 하나의 다형적 함수로 정의되며, 각 동물 객체는 자신만의 소리를 내게 됩니다.
- 이것이 동적 다형성의 장점 중 하나인 "여러 객체의 모둠을 우아하게 처리할 수 있다"입니다.
- **추상화**를 의미

🧐 **정적 다형성 (Static Polymorphism):**

- 정적 다형성은 일종의 마법 상자를 사용하는 것과 비슷합니다. 이 상자 안에 다양한 크기와 모양의 객체를 넣을 수 있지만, 상자는 내부의 객체들을 이해하고 다룰 수 있습니다.
- ex. 숫자를 더하는 함수를 생각해보세요. 이 함수는 정수, 실수, 분수 등 다양한 숫자 데이터 형식을 처리할 수 있습니다. 마치 마법 상자에 숫자를 넣으면 상자 안에서 자동으로 올바른 방식으로 처리되는 것과 같습니다. 이것이 정적 다형성의 장점 중 하나인 "내장 데이터형의 모둠이 쉽게 구현된다"입니다.
- **오버로딩**을 의미

### 배포형 컴포넌트

- 아키턱체의 경계가 물리적으로 날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리(jar 등)이다.

### 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야하는 경계가 혼합되어 있음을 의미한다.

🥲 18장 내용이 너무 추상적인 것 같다. 실제로 어떻게 해야하는지에 대해서 보단 이런게 있다 정도로만 이해하고 넘어간다.

---

### 19장. 정책과 수준

- 정책
    - 소프트웨어 시스템이란 정책을 기술한 것이다.
    - 좋은 아키텍처라면 각 컴포넌트를 연결 할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함.
    - 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계 되어야 한다.
- 수준
    - 수준(level)을 엄밀하게 정의 하자면 ‘입력과 출력까지의 거리’다.
    - 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
    - 암호화 프로그램 예제
        - 그림 19.2 시스템의 더 나은 아키텍처를 보여주는 클래스 다이어그램
            - 암호화 정책 : 고수준
            - 입출력 : 저수준
        - 인터페이스로 둘러싸고 있는 경계를 만들고 그 인터페이스를 구현 하도록 해야 입출력의 변화가 생기더라도 암호화 정책은 영향을 받지 않기 때문에 더 나은 아키텍처이다.
        
        🧐그러려면 p242 그림 22.1 클린 아키텍처에서 인터페이스 어댑터 영역에서 인터페이스를 작성하고 그 인터페이스를 구현하는 클래스를 작성해야 하는 것으로 이해.

---

### 5부 20장. 업무 규칙

- `업무 규칙` : 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다.
    - 핵심 업무 규칙 : 사업 자체에 핵심적 (ex. 은행 대출 이자율)
    - 핵심 업무 데이터 : 자동화되지 않은 경우에도 존재하는 데이터 (ex. 대출 잔액, 이자율, 지급 일정)

### 엔티티

- 핵심 업무 규칙을 핵심 업무 데이터로 구체화하는 시스템 내부의 객체

### 유즈케이스

- 자동화된 시스템이 사용되는 방법을 설명한다. (신규 대출)
- 유즈케이스는 어플리케이션에 특화된 업무 규칙을 설명한다.
- 유즈케이스는 사용자 인터페이스를 기술하지 않는다.
    - 어플리케이션에 특화된 규칙을 설명하고, 사용자와 엔티티 사이의 상호 작용을 규정하는데 주 목적이 있다.
- 유즈케이스는 저수준
    - 단일 어플리케이션에 특화
    - 해당 시스템의 입력과 출력에 가깝게 위치하고 있다.
- 엔티니는 고수준
    - 수많은 다양한 어플리케이션에서 사용될 수 있또록 일반화된 것
- 유즈케이스 → 엔티티 (의존)

### 요청 및 응답 모델

- 두 객체는 다른 이유로 변경될 수 있다.
- 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배한다.

---

## 5부 21장. 소리치는 아키텍처

- 잘 정의된 유즈케이스는 그 자체만으로도 아키텍처를 의미한다. (ex. 도서관)

### 아키텍처의 테마

- 부제 : 유즈케이스 주도 접근법
- 도구에 의존하여 아키텍처를 설계해선 안된다.

### 아키텍처의 목적

- `지엽적`인 관심사에 대한 결합을 분리시키고 유스케이스의 중점으로 좋은 아키텍처를 설계해서 프레임워크에 대한 선택 사항을 미룰수 있다. 이 말을 **열어 둬야할 선택사항**이다. 라고 말하고 있다.
    - `지엽적` : 본질적인 것이 아니고 부차적인 (것). 순화어는 `자질구레한'.

- 웹도 마찬가지다

### 테스트하기 쉬운 아키텍처

- 유즈케이스 전부에 대해서 **단위 테스트**를 할 수 있어야 한다.
- 프레임워크 등 의존해서는 안되고 객체 그 자체만으로도 테스트가 가능해야한다.

🤔 신규 대출 예시로 보면 신규 대출을 위한 프로세스는 비지니스 로직 그 신규 대출을 하기 위한 객체가 존재한다.

그 객체가 의미하는 값들을 전달하였을 때 비지니스 로직이 테스트가 가능해야한다.

---

## 5부 22장. 클린 아키텍처

- 지난 수 십년간 시스템 아키텍처와 관련된 여러 아이디어
    - Hexagonal Architecture(육각형 아키텍처 혹은 포트와 어댑터)
    - DCI(Data, Context, Interaction)
    - BCE(Boundary-Control-Entity)
- 목표는 **모두 계층 분리를 통한 관심사의 분리**이며 다음과 같은 특징을 지닌다.
    - 프레임워크 독립성: 프레임워크을 도구로 사용하며, 프레임워크가 지닌 제약사항으로 시스템을 강제하지 않음
    - 테스트 용이성: 업무 규칙은 UI, DB, 웹서버 및 다른 외부 요소 없이도 테스트할 수 있음
    - UI 독립성: 시스템의 나머지를 변경하지 않고도 UI를 쉽게 변경할 수 있음
    - 데이터베이스 독립성: 오라클이나 MS-SQL 서버 등을 다른 DB로 교체할 수 있고, 업무 규칙은 DB에 결합되지 않음
    - 외부 에이전시에 대한 독립성: 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못함
    ![1](https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/635fa26f-3bbf-43e7-b965-ff493c5371a3)
    그림 22.1 클린 아키텍처
    

### 의존성 규칙

- 안쪽으로 들어갈 수록 고수준의 소프트 웨어
- 바깥족 원은 매커니즘이고, 안쪽 원은 정책이다.
- 가장 중요한 규칙은 의존성 규칙이다.

> 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
> 

```
bank
│
├─ adapter
│  ├─ in
│  │  ├─ web          (웹 요청을 처리하는 컨트롤러 및 DTO)
│  │  └─ ui           (사용자 인터페이스를 처리하는 컴포넌트나 클래스)
│  │
│  └─ out
│     └─ persistence  (데이터베이스와의 연동을 위한 리포지토리나 DAO)
│       └─jpa 
│           └─ jpaEntity  (jpa를 사용할경우 @Entity는 여기)
│           └─ mapper    ( domain-entity 변환 mapper는 여기)
│
├─ application
│  ├─ port
│  │  ├─ in           (내부에서 사용하는 API 정의)
│  │  └─ out          (외부 시스템, 예: 데이터베이스, 다른 서비스와의 연동을 위한 인터페이스 정의)
│  │
│  └─ service         (유스케이스를 구현하는 서비스 클래스)
│
└─ domain             (도메인 모델, 엔터티, 값 객체, 도메인 서비스, 도메인 이벤트 등)
```

🤔  사이드프로젝트에 DDD와 헥사고날을 퓨전으로 적용하고 싶다.. 궁금증

[각각 쓰는지 이해 DDD와 Hexagonal](https://dataportal.kr/74)

🤔 그래서 도대체 뭘 어떻게 해야할까..?

[클린 아키텍처 패키지 구조 참고 링크](https://github.com/thombergs/buckpal)  
[지속 가능한 소프트웨어 설계 패턴: 포트와 어댑터 아키텍처 적용하기](https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture)
```
└── com
    └── linecorp
        └── sally
            ├── application
            │   ├── impl
            │   │   └── TotalRentalServiceImpl.java
            │   ├── InventoryService.java
            │   └── TotalRentalService.java
            ├── domain
            │   ├── item
            │   │   ├── Item.java
            │   │   └── ItemRepository.java
            │   └── member
            │       ├── MembershipService.java
            │       ├── User.java
            │       └── UserRepository.java
            └── interfaces
                ├── common
                │   ├── StoredItemDto.java
                │   └── UserDto.java
                ├── member
                │   ├── MembershipController.java
                │   ├── RegisterRequest.java
                │   └── RegisterResponse.java
                └── store
                    ├── StoreController.java
                    └── StoreRequest.java
```


### 엔티티

- 엔티티 계층에는 무언가가 변경이 필요하더라도 절대로 영향을 주어서는 안된다.

### 유스케이스

- 반복적으로 하는 말. 유즈케이스는 애플리케이션에 특화된 업무 규칙을 포함한다.
- 모든 유스케이스를 캡술화 하고 구현한다.
    - useCase Interface를 만들고 구현체를 따로 만들어서 코딩해야한다.

### 전형적인 시나리오
![3](https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/78d98748-08f2-4f5f-ad8f-5404ffec9895)

그림 22.2 데이터베이스를 사용하는, 웹 기반 자바 시스템의 전형적인 시나리오
