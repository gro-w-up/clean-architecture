## 15장. 아키텍처란?

(여담) 읽으면서 어려움을 느끼는 부분이 ‘컴포넌트’에 대한 정의같다. 그 규모가 내가 실질적으로 코딩하는 부분에 잘 대입이 안된다. → 내가 코딩하고 있는 스케일은, 이 장 끝에서 말하는 통짜 컴포넌트여서 그런것같다.

- 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 분리해야한다.
- 세부 사항에 대해 독립성을 유지하는 것이 훌륭한 아키텍처이다.
- 예를들어, 내게 가장 와닿는 세부사항 중 하나인 실제 DB종류에 대해 어떤것을 선택하건 문제가 되지 않고, 때문에 그 선택에 대한 결정을 최대한 미룰 수 있도록 하는것! 을 의미한다.
- 이 장에서 인상적이었던 부분은, “소프트웨어 아키텍처의 목표가 시스템을 제대로 동작하도록 만드는데 있다.”가 첫번째 목표가 아니라는 점이다.

<br>

## 16장. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
    - 시스템의 유스케이스
    - 시스템의 운영
    - 시스템의 개발
    - 시스템의 배포
- 유스케이스
    - 유스케이스(시스템의 행위)에 대해 영향력을 행사하기 위해서라기보다는, 아키텍처를 살핌으로써 해당 유스케이스의 의도를 명확히 확인할 수 있게 하기 위함이다.
- 운영
    - 같은 주소에서의 멀티 스레드, 독립된 주소 공간에서 실행되는 소수의 프로세스, 혹은 단일 프로세스에서 실행되는 단순 모노리틱 프로그램. 어떤 구조를 가질지 결정하는 것에 대해 열어두어야 한다.
    - 각 컴포넌트를 적절히 격리해놓는다면 추후에 어떤 구조를 가지게 될지라도 충분히 적용 가능하지만, 모노리틱 구조라면 분리를 요하는 다른 구조들로의 전환이 어려울 것이다.
- 개발
    - 아키텍처가 핵심적인 역할을 수행하는 부분이 바로 개발 환경 지원이다.
    - 콘웨이의 법칙
        - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
    - 독립적인 각각의 개발팀이 서로를 방해하지 않도록 아키텍처를 만들어야 한다.
- 배포
    - 목표는 '즉각적인 배포'다.
    - 위에 '개발 지원'에서와 마찬가지로 아키텍처는, 독립된 각각의 팀이 본인들의 변경사항이 적용된 컴포넌트를 즉각적으로 배포할 수 있도록 지원해야 한다.
- 저자는 이 책이 끝날 때까지 아래 두 사항에 대해 계속 얘기할 것 같다.
    - 선택사항을 열어놔라 - 현실적으로 위 사항들에 대해 균형적인 지원을 하기란 쉽지 않다. 요구사항도 계속 해서 변한다. 그러니 선택사항을 가능한한 많이, 오래 열어두어라. 변경을 쉽게 받아들일 수 있게하라.
    - 서로 다른 이유로 변경되는 것들은 분리시켜놔라. - 특히 ‘업무규칙’과 ‘세부사항’을 분리시켜라.
- 결합 분리 모드
    - ‘계층(ex. UI, 업무로직, 데이터베이스..)’을 수평적으로 분할하고 그걸 수직으로 가로지르는 ‘유스케이스’로 시스템을 분할한다.
    - (첨부된 그림을 보면 ‘주문 추가용 데이터베이스’와 ‘주문 삭제용 데이터베이스’가 분리돼있는데 그게 말이 되나?? 데이터베이스는 하난데? 리포지토리 분리라고 생각하려해도 저건 ‘주문’이라는 하나의 테이블에서 발생하는 일 아닌가..? 난 잘 모르겠다..)
    - 이전에 아는분이 회사에서 msa(micro service architecture)를 진행하고 있다고 해서 ‘그런것도 있군요,,’ 했었는데 이제 뭔지 알겠다. 분리하는 컴포넌트 수준이 ‘서비스’ 수준인것을 지칭하나보다.
- 이전에 내가 의문을 가졌던 중복에 대한 이야기가 나왔다. 이전에 ‘다른 목적을 갖는 코드들은 클래스를 명확하게 분리해라’ 라고 해서 ‘같은 역할을 수행하지만 목적이 다를 수 있다면 클래스를 분리해서 똑같은 코드를 중복해서 쓰라는 말이야? 중복을 최소화하라며!’ 라고 의문을 품었었는데 여기서 중복을 두가지 형태로 나누었다.
    - 진짜 중복
        - 리얼 중복이다. A에서 발생시킨 변경을 B에 똑같이 적용시켜야할 경우에 A와 B는 진짜 중복이다.
    - 우발적 중복
        - 중복이라고 착각하는 중복이다. 현재는 형태가 같을지라도, 추구하는 목표가 다르기때문에 추후에 다른 방향으로 발전할 것이고 나중에는 완전히 다른 형태를 갖게될 수도 있다.
    - 내가 개발하고 있는 서비스에서 ‘진짜 중복’을 분리해낸 경험이 있었다. 그 후 실상 ‘우발적 중복’이었던 것을 ‘진짜 중복’으로 착각해 분리해냄으로써 추후에 곤란해졌던 기억이 있다. 이제 두 차이를 명확히 알것같다.

<br>

## 17장. 경계: 선 긋기

- 이전에 현우님이 ‘프레임워크조차 선택사항으로 남겨둬야할까요’ 라고 의문을 던져주셨는데, 저자는 본인이 그렇게 함으로써 FitNess를 성공적으로 만들어냈다고 한다. 하지만 난 우리가 논의할 때 주장했던것처럼 그렇게까지해야할까? 싶었다. 물론 내가 아직 응애 개발자여서 그렇게 생각하는 것일 수 있겠으나, 프레임워크라는게 개발 편의성을 위해 사용하는 것 아닌가..?라는 생각이다..
- 선은 어디에?  관계 있는 것과 없는 것들 사이에.
- 그리고 의존성 화살표는 ‘저수준 세부사항 → 고수준 업무규칙’ 의 방향으로. ⇒ 이게 바로 플러그인 형태의 연결

<br>

## 18장. 경계 해부학

- 소스 수준 분리 모드: 물리적으로 엄격히 분리되어 있지 않은 형태로, 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있는 단일체(monolith). 하나의 실행 파일.
- 경계 횡단: 저수준 클라이언트 → 고수준 서비스 로 향하는 함수 호출
    - 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향으로 향한다.
        - 런타임 의존성이 제어흐름 을 의미하는 것 같다.
    - 저수준 클라이언트와 서비스 구현체 사이에 서비스 인터페이스를 두고, 클라이언트과 서비스 구현체 둘 다 인터페이스를 바라보게함으로써 컴파일타임 의존성을 역전시킨다.
- 다양한 예시들이 나오는데 결국 저자가 하고픈 말은 똑같다. 저수준 & 고수준 명확히 분리해서 고수준에 저수준에 대한 내용 안들어가게하고, 그 사이에 추상체 둬서 의존성 역전시켜라.

<br>

## 19장. 정책과 수준

- 자꾸 수준 얘기해서 이해 안가던 것이 여기서 정리가 됐다.
- 수준: 입력과 출력까지의 거리 ⇒ 시스템의 입/출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. 입/출력을 다루는 정책은 최하위 수준인것.
- 또 똑같은 얘기한다. ‘저수준 컴포넌트는 고수준 컴포넌트에 플러그인되어야 한다.’

<br>

## 20장. 업무 규칙

- 업무 규칙이란 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다. 자동이건 수동이건.
- 이러한 핵심 업무 규칙이 다루는 데이터가 핵심 업무 데이터 이다.
- 핵심 규칙과 핵심 데이터가 결합된 객체를 엔티티(Entity)라 한다.
- **엔티티**
    - 여기서 말하는 Entity는 내가 코딩할 때 만드는 그 모델객체만을 말하는게 아니라, 그 모델들을 비롯하여 해당 모델들을 직접적으로 다루는 함수들을 포괄하는 클래스? 컴포넌트? 소프트웨어 모듈? 을 의미한다.
- **유스케이스**
    - 비용을 줄이기 위해 핵심 업무 규칙을 자동으로 수행할 수 있다. 이러한 자동화 또한 비용을 줄이기 위한 수단이기 때문에 업무 규칙이라 할 수 있다.
    - 이렇게 사용자가 제공해야하는 입력, 사용자에게 보여줄 출력, 해당 출력을 생성하기 위한 처리 단계 와 같은 것을 기술한 것을 ‘유스케이스’라고 한다.
    - 엔티티가 ‘핵심 업무 규칙’이었다면, 유스케이스는 ‘애플리케이션 특화 업무 규칙’이다.
- 엔티티를 어떻게 이용할지 결정하는 것이 유스케이스다.
- 사용자(입출력)와 가까운 유스케이스는 저수준이고, 핵심업무규칙인 엔티티는 고수준이다. 유스케이스가 엔티티에 의존해야한다.
- **요청 및 응답 모델**
    - 유스케이스가 입출력에 가깝다고는 해도, 실제로 유저로부터 어떤 형태로 데이터를 받아올지 어떤 형태로 데이터를 전달할지 는 유스케이스의 고려사항이 아니다. 그저 데이터 그 자체인 간단한 객체로 주고받는 것이다.
    - 해당 형태를 결정하는 것은 세부사항이다. 세부사항이 업무규칙에 관여해서는 안된다.

<br>

## 21장. 소리치는 아키텍처

- 아키텍처를 살폈을 때, 해당 소프트웨어가 어떤 목적의 소프트웨어인지를 알아낼 수 있도록 설계하라고 한다. 프레임워크 중심으로 만들어버리지 말라고 한다.
- **하지만 웹은?**
    - 웹 또한 세부사항이다. 해당 소프트웨어가 어떤 형태로 전달될지는 나중에 결정할 일이란 얘기다.
- 프레임워크도, 어떤 형태의 서비스인지도 저자는 ‘그것들은 세부사항이니 나중에 정해라’라고 하는데.. 이제보니 특정 개발자가 본인을 소개할 때 말하는 것(‘**스프링**으로 **웹서비스** 개발하는 백엔드 개발자입니다.’)들을 저자가 나중에 정하라 할 때 이론과 실전에서 괴리를 느끼는 것 같다.
- **결론**
    
    “모델처럼 보이는 것들을 확인했습니다. 그런데 뷰와 컨트롤러는 어디에 있죠?”
    
    “아, 그것은 세부사항이므로 당장은 고려할 필요가 없습니다. 나중에 결정할 겁니다.”
    
    - 나는 거의 컨트롤러를 먼저 만들고 거기서 호출할 함수들을 정리하는 편이다. 컨트롤러를 먼저 생각해놔야 이번 장에서 말한 그 유스케이스라는 유저플로우가 그림 그려지면서 어떤 함수를 작성해야할지 정해지기 때문이다.
    - 근데 저자가 말하는건 필요한 기능들을, 서비스들을 우선 작성하고(핵심 기능) 이를 어떻게 사용할지는 나중에 정하라는 것 같다.
    - 읽을수록 내가 가야할 방향성을 찾기가 더 어려워지는 것 같다…

<br>

## 22장. 클린 아키텍처

- ‘클린 아키텍처’라고 제시하는 다이어그램이 있다.
    - 최외각부터해서, 
    ‘프레임워크와 드라이버’ > ‘인터페이스 어댑터’ > ‘애플리케이션 업무 규칙’ > ‘엔터프라이즈 업무 규칙’
    - 프레임워크와 드라이버
        - UI, 웹, 장치, DB, 외부 인터페이스
    - 인터페이스 어댑터
        - 컨트롤러, 게이트웨이, 프레젠터
    - 애플리케이션 업무 규칙
        - 유스케이스
    - 엔터프라이즈 업무 규칙
        - 엔티티
- 해당 다이어그램에서 의존성은 안쪽으로 향해야하고, 안쪽(A)에서 바깥쪽(B)으로 의존성이 발생해야할 때는 인터페이스(B’)를 안쪽에 배치시켜 안쪽(A)과 바깥쪽(B) 모두 안쪽의 인터페이스(B’)를 의존하도록 한다. ⇒ 의존성 역전
- 데이터베이스에 대한 선택을 미룬다는건 ORM 사용은 이미 그냥 배제인건가??
- **경계를 횡단하는 데이터는 어떤 모습인가**
    - 이게 좀 더 자세히 나왔으면 좋겠는데,, 컨트롤러에서 서비스단으로 파라미터를 보낼 때 어떤 형태가 가장 이상적인지 아직 잘 모르겠다.
    - 클린코드에서는 파라미터를 세개 이상 보내지 말라고 했다. 여러개 보내고 싶으면 DTO 이용하라 해서 그렇게 해보려고 했는데, 그럼 컨트롤러마다 DTO를 지정해줘야하나 생각이 들었고,, DTO를 지정하는 형태가 내가 알고 있는 그 모습만 있는 것이 아닌건가 하는 의문도 들었다.

<br>

## 23장. 프레젠터와 험블 객체

- **험블 객체 패턴**
    - 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 분리한 패턴이다.
    - 여기서 테스트하기 어려운 행위인 모듈을 험블(humble) 객체라 한다.
- **프레젠터와 뷰**
    - 그 예로 ‘프레젠터와 뷰’가 언급되는데, 이처럼 같은 행위(데이터를 보여줌)를 두가지 모듈(프레젠터 & 뷰)로 나누는 것이다.
    - 프레젠터는 애플리케이션으로부터 사용자에게 보여야할 데이터를 받고, 적절한 포맷으로 만들어 뷰에게 전달한다.
    - 뷰는 프레젠터로부터 받은 데이터들을 그저 보여줄 뿐이다.
    - 뷰는 테스트하기에는 어렵고 하는 일은 보잘것없는(?) 험블 객체이다.
- **데이터베이스 게이트웨이**
    - 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
    - 이 게이트웨이는 다형적 인터페이스로, 유스케이스가 DB에 접근할 수 있는 메서드들을 제공한다.
    - 유스케이스 계층에는 결코 SQL이 들어설 수 없고, 때문에 게이트웨이의 메서드를 이용한다. 그리고 게이트웨이의 구현체는 데이터베이스 계층에 위치한다. 이 구현체가 험블객체이다.
- **데이터 매퍼**
    - Object Relational Mapper, ORM이 위에서 언급한 역할을 하는 험블객체인것같다.
    - 게이트웨이 인터페이스와 데이터베이스 사이에 경계를 형성하며 데이터베이스 계층에 위치한다.
- **결론**
    - 아키텍처의 경계에 험블 객체 패턴을 발견할 수 있을 것이라 한다.
    - 내가 이해한 바로는, 상대적 고수준에 위치한 인터페이스가 테스트하기 쉬운 대상이고, 상대적 저수준에 위치한 해당 인터페이스의 구현체가 테스트하기 어려운 험블 객체이다.

<br>

## 24장. 부분적 경계

- 경계를 만드는 일은 비용이 많이 드는 일이면서, 사실 지금 당장 요구되는 작업은 아니다. 나중에 힘들지 않도록 선행작업을 하는 것이니까. 때문에 완전 경계를 만드는 것이 아닌 부분적 경계를 구현해보라고 제안한다.
- 부분적 경계를 구현할 수 있는 세 가지 방식에 대해 설명한다.
- **마지막 단계를 건너뛰기**
    - 완벽한 경계를 만들어 모두 구현한 뒤, 분리하지는 않고 모두 단일 컴포넌트로 컴파일해서 배포한다.
    - 엥 이게 맞아? 싶은 순간 저자가 바로 말한다. ‘다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다. 추적을 위한 버전 번호도 없으며, 배포 관리 부담도 없다. 이 차이는 가볍지 않다.’ (역시나 단일 컴포넌트로만 구현해본 나에게는 와닿지 않는 말이긴 하다.)
- **일차원 경계**
    - Client는 Service Boundary Interface를 의존하고, Service Impl은 해당 인터페이스를 구현하는 전략(Strategy) 패턴을 들었다.
    - 이 책에서 봐온 형태가 저 형태같은데, 저자는 Service Impl이 Client를 의존하게 될 위험한 가능성에 대해 언급한다. 그동안 책에서 제시한 형태가 저게 아니었던건가..?
- **퍼사드**
    - 의존성 역전도 없다. 경계는 Client와 Facade 클래스 사이에만 존재한다.
    - Client는 Facade 클래스에 의존하고, Facade 클래스는 모든 서비스 클래스를 메서드 형태로 정의하고 요청 받은 서비스 호출을 해당 서비스 클래스에 전달한다.
    - Client가 서비스 클래스에 직접 접근할 일은 없으나, 추이 종속성을 가지게 된다.
        - 추이종속성: 의존성의 형태가 A → B, B → C로 존재할 때, A → C의 의존성을 의미한다.

<br>

## 25장. 계층과 경계

- 시스템의 기본적인 컴포넌트 세가지: UI, 업무 규칙, 데이터베이스
- 이 세가지 외에 컴포넌트 개수는 훨씬 많다.
- **클린 아키텍처? (feat. 움퍼스 사냥 게임)**
    - `Text Delivery` → `Language` → `Game Rules` ← `Data Storage`
    - 해당 게임은 위 컴포넌트와 같이 구성될 수 있다.
    - Text Delivery, Language, Data Storage는 각각 추상 컴포넌트인데, 각각을 구현하는 구현체(세부사항)에 대해 서로가 알 필요는 없다.
    - 그리고 API는 사용하는 쪽에 정의되고 소속된다. 구현하는 쪽이 아니라.
        - Language와 Data Storage는 Game Rules에 정의되고, Game Rules는 본인이 정의한 인터페이스를 사용한다. 그리고 각각을 구현하는 구현체(English, Spanish / Cloud Data, Flash Data)는 각각의 영역(Language / Data Storage)에 구현된다.
        - 마찬가지로 Text Delivery는 Language에 정의되고, Text Delivery에서 SMS, Console 등의 세부사항을 담은 구현체로 구현한다.
    - Game Rules가 최상단에 놓인 단일 컴포넌트임을 확인할 수 있다.
- **흐름 분리하기**
    - 최상단에 놓인 Game Rules 도 또 다시 분리될 수 잇다.
    - 플레이어들의 행위에 대한 정책인 Move Management와, 해당 정책에서 발생한 행위에 의한 결과(플레이어의 상태)를 관리하는 Player Management로 나눌 수 있다.
    - Move Management는 플레이어의 행위(FoundFood, FellInFit 등)의 사건이 발생했음을 고수준 정책인 Player Management로 전달하고, 해당 컴포넌트에서 플레이어의 상태를 관리하는 것이다.
- **결론**
    - 이처럼 단순한 시스템에도 경계는 어디에나 존재한다.
    - 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.
    - 하지만 필수적인 경계에 대한 설계를 하지 않고 추후에 필요성을 발견하여 추가하려고 한다면 비용이 많이 든다.
    - 때문에 미래를 세심히 추측해야하는데, 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현해야한다.

<br>

## 26장. 메인(Main) 컴포넌트

- 모든 시스템에는 ‘메인(Main)’이라는 최소한 하나의 컴포넌트가 존재한다.
- **궁극적인 세부사항**
    - 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다. 메인은 시스템의 초기 진입점이다. 운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.
    - 의존성 주입이 바로 이 메인 컴포넌트에서 이뤄져야 한다.
- **결론**
    - 메인을 애플리케이션의 플러그인이라고 생각하자.
    - 메인은 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.

<br>

## 27장. '크고 작은 모든' 서비스들

- **서비스 아키텍처?**
    - 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다.
    - 아키텍처적으로 중요한 서비스도 있고 아닌 서비스도 있다는데, 여기서 말하는 서비스가 어떤 의미인지 잘 파악이 안된다.
- **서비스의 이점?**
    - **결합 분리의 오류**
        - 여전히 어떤 서비스를 말하는 것인지 모르겠지만 여기서 말하는 특별할 것 없는 이점은 뭔지 알겠다.
        - 서비스를 확실히 분리한다고 하더라도 결국에는 서비스들끼리 통신해야하기 때문에 해당 통신 수단에 의해 간접적으로 강하게 결합된다는 것이다.
        - 긍께 함수 수준의 분리나 서비스 수준의 분리나 아키텍처적으로 비슷하다고 말하는 것 같다.
    - **개발 및 배포 독립성의 오류**
        - 서비스를 사용하면 전담팀이 서비스를 소유하고 운영한다. 팀 단위로 책임지고 유지보수하고 배포하고 확장할 수 있는 것이 이점이다.
        - 근데 그 이점은 서비스 시스템만으로 얻을 수 있는 이점이 아니라고 한다. 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다고 한다.
        - (이정도면 억까 아닌가)
        - ‘결합 분리의 오류’에 따르면 서비스라고 해서 항상 독립적으로 개발하고 배포하고 운영할 수 있는 것은 아니고, 조정이 필요하다고 한다. (그건 다 그런거아닌가..?)
- **야옹이 문제**
    - 예시로 들어준 야옹이 문제는, 택시 통합 서비스에서 서비스를 Taxi UI, Taxi Finder, Taxi Selector, Taxi Supplier, Taxi Dispatcher로 나누어서 운영중일 때 유사하지만 다른 ‘야옹이 배달’ 서비스를 새롭게 시작하려 할 때 해당 서비스들을 갈아엎어야한다는 것이다. 나열한 서비스들이 모두 긴밀히 연결되어 있기 때문이다.
    - 횡단 관심사 라고 한다.
- **객체가 구출하다**
    - 이를 컴포넌트 기반 아키텍처로 운영했더라면 해결했을 방식을 제시한다.
    - 사실 잘 이해가 안가는데, 위에서 나열한 서비스들을 추상 기반 클래스들로 만들고, 기존 배차 시스템에 특화된 로직 부분을 Rides 컴포넌트로, 야옹이에 대한 신규 기능을 Kittens 컴포넌트로 만들어 추상 클래스들을 구현한다(오버라이드한다).
    - 이러한 형태를 통해 기존 코드의 변경을 최소화하며 확장할 수 있고, 야옹이 기능은 독립적으로 개발 및 배포할 수 있게된다.
- **횡단 관심사**
    - 아키텍처 경계가 서비스 사이에 있지 않다. 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.
    - 아직까지도 뭔말인지 잘 모르겠는데, 어렴풋이 이해한 느낌으로는,, 앞서 위에 야옹이 문제에서 나열한 저 서비스 단위. 그 사이가 아키텍처적으로 경계가 아니라고 말하는 것 같다. 저렇게 서비스적으로 경계가 형성되는 것이 아닌, 해당 서비스들을 추상화 함으로써 각 서비스 내부적으로? 경계(추상체와 구현체 사이)를 형성해야 한다고.. 말 하는 것 같다..
- **결론**
    - 우리가 일반적으로 생각했을 때 나뉘는 그 경계는 보통 서비스 단위로 나뉘어지는데(예를들어 공급자와 수요자 그 사이), 그 경계는 아키텍처적으로 나뉘어져야만하는 경계는 아니다.
    - 가 저자가 말하는 것이 아니었을까 라고 추측해본다.

<br>
