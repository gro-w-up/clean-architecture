> **SOLID**

## 7장. SRP: 단일 책임 원칙

- 메서드와 클래스 수준의 원칙.
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 클린코드에서는 하나의 함수는 하나의 기능만을 수행해야한다고 지겹도록 말한다. 그와 같은 맥락인걸까?
- 예시를 보면,
  - 전혀 다른 목적의 액터들이 하나의 클래스를 바라보고 있고,
  - 그 내부에는 각각의 액터가 사용할 기능들이 존재한다.
  - 그 중 두개의 기능(A, B)에서 중복되는 부분을 또 다른 메서드(x)로 빼고,
  - 각각의 기능(A, B)이 새로 만든 메서드(x)를 호출하는 방식으로 변경한다.
  - 그러던 중 하나의 기능(A)이 본인의 기능을 수정하고 싶어서 살펴보니 본인이 호출하고 있는 메서드(x)를 수정해야 하는 것이다.
  - 그래서 수정한다.
  - 그 메서드(x)를 호출하고 있던 또 다른 기능(B)은 암것도 모른채 변경된 방식을 이용하게 된다.
    ⇒ 예시가 말하고자 하는 바는 명확히 알겠다.
    ⇒ 근데 그럼 각기 다른 액터에 대응하는 기능들은 그것이 중복될지라도 따로 작성하란 의미가 맞는건가?
- 해결책으로 Facade 패턴에 대한 설명이 나왔는데, 뭔소린지 모르겠다,,

<br>

## 8장. OCP: 개방-폐쇄 원칙

- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 의존에 있어 하위에 있는(호출되는) 코드를 직접 수정하기보다는, 그 상위에 뭔가를 추가하는 방식이 가능하도록 구성하라는 의미 같다.

<br>

## 9장. LSP: 리스코프 치환 원칙

- 하위 타입에 대한 정의
  - S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
- 잘 정의된 인터페이스와, 해당 인터페이스를 구현한 많은 구현체들이 있다면, 해당 구현체들끼리 바뀌어도(상호 치환) 잘 굴러간다.
- 택시 어플 예시에서 해결책으로 나온 부분(파견 명령 생성 모듈) 잘 모르겠다.

<br>

## 10장. ISP: 인터페이스 분리 원칙

- 예시를 보면 오퍼레이션이 한 클래스에 묶여있을 때 한 오퍼레이션의 변동으로 인해 통째로 재배포를 발생시키지 않기위해, 각 오퍼레이션의 인터페이스를 분리하여 오퍼레이션 사용자들이 직접 오퍼레이션 클래스에 의존하지 않도록 하라고 한다. (오퍼레이션 클래스가 아닌 인터페이스에 의존)
- 근데 원래 배포는 통째로 배포하는거 아닌가…. 라이브러리에 있는 파일들에 대한 얘기인것일까…? 인터페이스를 분리하라는 얘기는 이해가 가는데 그 이유의 예시가 이해가 안간,,다,,

<br>

## 11장. DIP: 의존성 역전 원칙

- 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템.
- 인터페이스를 잘 설계해서 안정적으로 만들고, 그 인터페이스에 의존하도록 코드를 작성해라.
- 의존성 방향 ≠ 제어흐름 방향 ⇒ 의존성 역전

<br>

### 내가 봤을 때 그냥 모든 원칙이 다 결국 똑같은 얘기하는 것 같다.
