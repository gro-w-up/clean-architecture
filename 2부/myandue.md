## 3장. 패러다임 개요

- 구조적 프로그래밍
  - 최초로 적용된 패러다임
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍
  - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 각 패러다임은 새로운 권한을 부여하는 것이 아닌, 권한을 박탈한다. 즉, 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지를 말해준다.

<br>

## 4장. 구조적 프로그래밍

- 증명 가능한 가장 작은 단위인 모듈로 구성
- 기능적 분해
  - 거대한 문제 기술서 → 고수준의 기능들로 분해 → 저수준의 함수들로 분해
- 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용하여 표현할 수 있다.
- 이러한 구조적 접근으로, 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화 할 수 있다.
- 하지만 위에서 말하는 입증의 형태는, ‘서술된 내용이 사실이다’와 같은 증명이 아닌, 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주는 형태이다.
- 즉, 구조적 프로그래밍은 ‘반증 가능한 단위’를 만들어내는데에 가치가 있다.

<br>

## 5장. 객체 지향 프로그래밍

- 많은 사람들이 객체지향의 본질을 설명하기 위해 ‘캡슐화’, ‘상속’, ‘다형성’을 거론하는데, 저자는 ‘다형성’을 가장 크게 보고 실상 ‘캡슐화’, ‘상속’은 그 이전부터 사용되어 왔기에 딱히 객체지향언어릐 특징이 아니라고 한다.
- 다형성
  - 사실 다형성에 대해 내가 완전히 이해하고 있지 못해서 뭔말인지 모르겠다.
  - 객체지향 이전에도 함수에 대한 포인터를 직접 사용해 다형적 행위를 만들었는데, 포인터를 사용하려면 포인터 초기화를 꼭 지켜야만하지만 객체지향언어는 이러한 관례를 없애줬다고 한다.
  - 하나의 목적을 갖는 기능을 상태에 대해 독립적일 수 있게 하는것..으로 보인다.
- 의존성 역전
  - 의존성 역전이랑 다형성이랑 뭔 상관인가, 했는데 내가 이해한 바로는 이렇다.
  - 인터페이스 같은 걸까?? DB의 종류에 상관없이 DB를 연결하는 부분을 인터페이스로 구현해놓으면 DB가 로컬DB건 뭐 mysql이건 정해졌을 때 연결해주면 된다. 다형성이란게 그런 의미이려나..?
  - 계속해서 ‘소스 코드 의존성’과 ‘제어흐름’에 대해 나오는데, 의존성은 알겠는데 도대체 제어흐름이 뭘 의미하는지 모르겠다.
    - 소스 코드 의존성: 소스코드 그 자체를 호출하는 것을 의미. A가 B를 호출하면 A는 B에 의존한다. A → B
    - 제어흐름: 실질적으로 필요한 정보 제공의 형태? A가 C 데이터베이스에 있는 정보를 가져다 쓸경우 A - -> C
    - B가 데이터베이스 관련 인터페이스라면 실상 A는 C의 정보를 가져다 쓰지만(제어흐름) 직접적으로 C를 호출하지는 않는다. 라는 것이 ‘의존성 역전’ 같다. 의존성 방향 ≠ 제어흐름 방향

<br>

## 6장. 함수형 프로그래밍

- 함수형 언어에서 변수는 변경되지 않는다.
- 불변성이 중요한 이유: 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.
- 완전 불변성은 말이 안되고, 타협해볼 수 있는 수단은, 가변 컴포넌트와 불변 컴포넌트를 분리하는 것이다.
  - 불변 컴포넌트: 가변 변수 사용X, 순수하게 함수형 방식으로 처리
  - 그리고 불변 컴포넌트는 하나 이상의 가변 컴포넌트와 서로 통신한다.
- ‘애플리케이션은 CRUD가 아니라 그저 CR만 수행한다.’ 라는 말로 ‘불변’에 대해 조금은 이해가 갔다. 기존의 데이터를 수정하거나 삭제하는 것이 아니라 계속해서 새로운 데이터를 생성만 한다는 의미. 그래서 저장 공간과 처리 능력이 충분하면 완전한 불변성(에 따른 완전한 함수형) 애플리케이션이 가능하다고 한다.
- 근데 난 ‘불변성’이 왜 함수형 프로그래밍의 특징인건지는 모르겠다.
